<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Introduction to Java Server Faces</title>
  <meta name="author" content="Justyna Horwat with Ed Burns">
</head>
<body>
<h1>JavaServer Faces Overview
</h1>
<p>JavaServer Faces (JSF) makes it easy to build powerful and dynamic
web
applications. There are many web user interface frameworks available,
but JSF stands out for several reasons: it is a Java Community Process
standard, it brings JavaBeans paradigms to Web UI programming, and it
was built by taking the best ideas from many existing frameworks.&nbsp;
As
a standard, many tool venders can rely on well defined and consistent
behavior. JSF was designed for use inside of tools from the very
beginning. Users can also rely on consistent and specific behavior from
one JSF implementation to the next.
</p>
<p>There are many features available in JSF. Some of the main feature
highlights include:
</p>
<ul>
  <li>
    <p> managed bean facility</p>
  </li>
  <li>validation facility<br>
  </li>
  <li>
    <p> rich and extensible component library </p>
  </li>
  <li>
    <p> pluggable renderkits </p>
  </li>
  <li>
    <p> managed bean facility </p>
  </li>
  <li>
    <p> navigation in response to specific user events</p>
  </li>
  <li>preserving application state across requests<br>
  </li>
  <li>
    <p> conversion model </p>
  </li>
</ul>
<p>This article will give an overview and examples of some of these JSF
features.
</p>
<p>A JSF application is essentially a servlet or JSP application
running on
a J2EE 1.3 compliant container. This means Servlets version 2.3 and JSP
version 1.2.&nbsp; On a side note, JSF does not require that JSP pages
be used in the application, you're free to use straight up Servlets or
another templating technology. With JSP,
you can use the built-in JSF Core and HTML component libraries via the
JSF custom component tags. The JSF components represent web controls
like text fields, forms, buttons, tables, checkboxes, and so forth.
</p>
<p>When you create a JSP page with JSF components, a component tree is
built in memory on the server, with each component tag corresponding to
a UIComponent instance in the tree. This component tree is used by the
framework
to handle your application request and create a rendered response. When
the user generates an event, for example, by clicking on a button, the
JSF
lifecycle handles that event and generates an appropriate
response.&nbsp; This is a familiar paradigm common to most forms of
grpahical user interface programming.<br>
</p>
<p>The FacesServlet is the entry point into the JSF framework. It
handles
the request processing lifecycle and acts as a front controller. JSF
also has the notion of a context where important information request
information is stored. That object is called the FacesContext. It is
modified at each stage of the JSF Lifecycle and is valid per-request.
</p>
<p>jmh: NOTE: Add more text going over what JSF is</p>
<p>jmh: NOTE: Include information on the JSF EL</p>
<h2>Simple JSF Application
</h2>
<p>This article includes a simple JSF application that illustrates some
of
the important JSF concepts. In order to understand the application, you
should already be familiar with basic J2EE web technologies including
JSPs, Servlets, and Tag Libraries.
</p>
<p>The basic high-level idea behind the sample application is to engage
the
user in a quick fantasy game. Have you ever wondered what would happen
if you took two characters from <span style="font-style: italic;">The
Lord of the Rings</span> and pitted them against
another? The sample application answers that question in a simple and
fun way. The application is called Character Combat.
</p>
<p>Character Combat consists of the following:
</p>
<ul>
  <li>
    <p> - JSP pages with JSF components representing the view </p>
  </li>
  <li>
    <p> - Backing bean to hold the model data </p>
  </li>
  <li>
    <p> - Application configuration files specifying: </p>
  </li>
  <ul>
    <li>
      <p> - JSF controller servlet </p>
    </li>
    <li>
      <p> - managed beans </p>
    </li>
    <li>
      <p> - navigation handling </p>
    </li>
  </ul>
</ul>
<img src="workflow.jpg" title="" alt="Workflow Diagram"
 style="width: 437px; height: 165px;"><br>
The above diagram shows the page flow through the
application.&nbsp; On the first page, the user can either add
characters, or go straight to the next page.&nbsp; On the second page,
the user can go back to the first page and add more characters, choose
the first participant in the battle, or go to the third page.&nbsp; On
the third page, the user can go back to the second page, choose the
second participant in the battle, or go to the final page.&nbsp; On the
final page, the user can see the results of the battle, go back to the
third page, or restart at the beginning.<br>
<br>
You wil note that this workflow lends itself to the "wizard" UI design
pattern.&nbsp; We have extracted the wizard functionality of this
example into a simple reusable bean for your own applications.&nbsp;
For more on the wizard bean, see the below section: <span
 style="font-weight: bold;">Example Wizard Component</span>.<br>
<h2>Managed Beans
</h2>
<p>A managed bean is simply a java class with a public, no-args
constructor, that conforms to the JavaBeans 1.0 naming conventions for
method names, and is identified to the Faces application using the
managed bean facility.&nbsp; The managed bean facility is configured in
the WEB-INF/faces-config.xml file.&nbsp; You can place any number of
<code>&lt;managed-bean&gt;</code> declarations in this file, giving
each one a name,
class, and scope.&nbsp; In your web
application itself you simply reference the bean using your defined
bean
name in a JSF Expression Language expression. The bean will be created
and placed in the appropriate scope the
first time you reference it. Managed beans are very flexible and allow
you to customize your bean by specifying properties, including java
arrays, Maps, Lists, and other managed beans.
</p>
<p>The Character Combat example has a backing bean called ModelBean.
Here
is how the ModelBean is defined in the WEB-INF/faces-config.xml file
using the managed bean facility:
</p>
<pre><code><br>  &lt;managed-bean&gt;<br>    &lt;managed-bean-name&gt;modelBean&lt;/managed-bean-name&gt;<br>    &lt;managed-bean-class&gt;characterCombat.ModelBean&lt;/managed-bean-class&gt;<br>    &lt;managed-bean-scope&gt;session&lt;/managed-bean-scope&gt;<br>  &lt;/managed-bean&gt;<br></code></pre>
<p>That bean is then referenced in the web application's JSP pages.
Here is
an example of how the bean is used:
</p>
<pre><code><br>  &lt;h:inputText value="#{modelBean.customName}" /&gt;<br></code></pre>
<p>Where &lt;h:inputText/&gt; is a text field component nested in a
form. When the form is submitted, the value in the text field will be
saved as a "customName" property in the ModelBean.
</p>
<h2>Object Model
</h2>
<p>The Character Combat example creates a ModelBean object. ModelBean
includes a set of accessor methods just like any other JavaBeans
component. It also pre-populates a default list of characters as well
as
stores the user customized character.
</p>
<p>The ModelBean is created using the Managed Bean Creation Facility
and
referenced by name in the JSF components defined in the view. The
ModelBean illustrates how a bean can be used to store the value of the
component.
</p>
<p>In the example only the addition of new characters is supported. A
nice extension to the application would allow deletion functionality by
modifying the model and view to support this feature.
</p>
<h2>JSP Pages
</h2>
<p>jmh: NOTE: would be nice to graphically display the component tree
for some of the component examples</p>
<p>The JSP pages provide the view for the web application. JSF provides
two JSP tag libraries that expose the components to the page
author.&nbsp; You can customize these components or create your
own.&nbsp; The standard components render themselves as basic HTML
4.01, with the absolute minimum of javascript.&nbsp; This ensures that
there is a high likelyhood that your page will render as expected in
all browsers.&nbsp; If you need support for other rendering types, such
as WML, or SVG, JSF includes the concept of a RenderKit, which is a
software module used by the components to render themselves into a
particular client device type.&nbsp; <br>
</p>
<p>To use the built-in JSF tag libraries that contain the components,
you
will need to include the following tag directives in your JSP page:
</p>
<pre><code><br>&lt;%@ taglib uri="http://java.sun.com/jsf/core"  prefix="f" %&gt;<br>&lt;%@ taglib uri="http://java.sun.com/jsf/html"  prefix="h" %&gt;<br></code></pre>
<p>Note that your JSF page will need to have all of the JSF tags
enclosed in between the &lt;f:view&gt;...&lt;/f:view&gt; tags so that
the component tree is properly created.</p>
<p>Each HTML component can be customized using stylesheets. You can
specify
a generic styleClass or set specific style attribute values for each
component<br>
</p>
<p>Here are some examples from the Character Combat application that
illustrate the above concepts:
</p>
<h2> DataTable
</h2>
<p> The DataTable UIComponent can handle several different types of
DataModel including java.util.List and java.sql.ResultSet, among
others. It takes the data and lays it
out in a customizable table. The component can also be customized using
stylesheets.
</p>
<p> In the Character Combat demo a List is used as the underlying
DataModel. Here is a code snippet:
</p>
<pre><code><br>  &lt;h:dataTable columnClasses="list-column-center,<br>                              list-column-center,<br>                              list-column-center,<br>                              list-column-center"<br>		          headerClass="list-header"<br>		          styleClass="list-background"<br>		          value="#{modelBean.dataList}"<br>		          var="character" &gt;<br><br>    &lt;f:facet name="header"&gt;<br>	   &lt;h:outputText value="List of Available Characters"/&gt;<br>    &lt;/f:facet&gt;<br><br>    &lt;h:column&gt;<br>	   &lt;f:facet name="header"&gt;<br>	     &lt;h:outputText value="Name"/&gt;<br>	   &lt;/f:facet&gt;<br>      &lt;h:outputText value="#{character.name}"/&gt;<br>    &lt;/h:column&gt;<br><br>    &lt;h:column&gt;<br>	   &lt;f:facet name="header"&gt;<br>	     &lt;h:outputText value="Species"/&gt;<br>	   &lt;/f:facet&gt;<br>	   &lt;h:outputText value="#{character.species.type}"/&gt;<br>    &lt;/h:column&gt;<br>...<br>  &lt;/h:dataTable&gt;<br></code></pre>
<p> As you can see in this example #{modelBean.dataList} evaluates to a
list of character entries stored in the "character" variable as defined
the the &lt;h:dataTable/&gt; tag. For each character in the list a new
row is created and displayed according to the &lt;h:column/&gt; tags.
</p>
<p> The &lt;f:facet/&gt; tag creates a special relationship between the
component enclosed in the facet and it's parent. This special
relationship allows you to define components to be headers or footers.
In our example, we use a facet to create header for our columns.
</p>
<p> Since the &lt;h:dataTable/&gt; is an HTML component, it's style can
be customized using stylesheets. In our example we show how you can use
style attributes for several of the different &lt;h:dataTable/&gt;
properties. We import our stylesheet named "stylesheet.css" using the
following code snippet in the JSP page header:
</p>
<pre><code><br>  &lt;link rel="stylesheet" type="text/css"<br>    href='&lt;%= request.getContextPath() + "/stylesheet.css" %&gt;'&gt;<br></code></pre>
<h2> PanelGrid
</h2>
<p> For simple table layout you can use the &lt;h:panelGrid/&gt;
component. Unlike the DataTable component, PanelGrid does not take any
underlying data model.
</p>
<p> Here is an example of a two column table containing a set of
buttons:
</p>
<pre><code><br>    &lt;h:panelGrid columns="2"&gt;<br>	    &lt;h:commandButton action="#{modelBean.select}" value="Next Page"/&gt;<br>	    &lt;h:commandButton action="#{modelBean.addCustomName}" value="Add Name"/&gt;<br>    <br></code></pre>
<h2> InputText
</h2>
<p> The InputText component is one way that you can use to get
information submitted by the user. In our example we link the text
field to our model by specifying the value attribute as follows:
</p>
<pre><code><br>	&lt;h:inputText value="#{modelBean.customName}" /&gt;<br></code></pre>
<p> This InputText component is nested in a form. Once that form is
submitted, the value in the field will be reflected in our model.
</p>
<h2> OutputText
</h2>
<p> The OutputText component can display information in various ways.
You can, for instance, configure it to either escape HTML markup,
changing all occurrences of angle brackets to the apropriate &amp;lt;
syntax, or to pass through the markup unchanged. You
can also apply various stylesheet styles to the component.
</p>
<p> OutputText is used throughout the sample application to display the
data from the model. In this example we are displaying the character's
name:
</p>
<pre><code> &lt;h:outputText value="#{character.name}"/&gt; </code></pre>
<h2> SelectOneRadio
</h2>
<p> You can use the SelectOneRadio to display a set of radio
selections. You can include a set of radio select items as well as
nested item groups. Here is how SelectOneRadio is used in our example:
</p>
<pre><code><br>	&lt;h:selectOneRadio<br>	  layout="pageDirection"<br>	  value="#{modelBean.currentSelection}"&gt;<br>	  &lt;f:selectItems<br>	    value="#{modelBean.charactersToSelect}" /&gt;<br>	<br><br></code></pre>
<p>The layout attribute tells the &lt;h:selectOneRadio/&gt; component
to
layout vertically as opposed to the horizontal default layout. Our
ModelBean charactersToSelect method returns a List of SelectItems which
the SelectOneRadio knows how to display. This radio component is nested
in a form. The selected radio item when the form is submitted will be
saved as the currentSelection property in the model.
</p>
<h2> CommandButton
</h2>
<p> CommandButton is an input component that can create Action Events.
You can create ActionListeners to look for specific action events as
the user is navigating through your JSF web application. You can also
supply an action method binding for an application action to be invoked
when the component is selected. This latter case is what we use in our
sample:
</p>
<pre><code><br>    &lt;h:commandButton<br>	    action="#{modelBean.addFirstSelection}"<br>	    value="Submit First Character Selection"/&gt;<br></code></pre>
<p> We will discuss actions in the next section since they are very
important in navigation handling.
</p>
jmh: NOTE: talk about actions...
<h2>Navigation: the Example Wizard Component</h2>
Let's take a look at the wizard component that handles navigation in
the app.&nbsp; There are
three parts to this component, shown by the black shapes in this
diagram.<br>
<img src="wizard.jpg" title="" alt="wizard diagram"
 style="width: 444px; height: 494px;"><br>
The user must do two things to use this component.&nbsp; 1. include it
in your UI, 2. author the navigation rules accordingly.&nbsp; We'll
cover these&nbsp; steps in detail below.&nbsp; The details of the
WizardButtons managed bean are beyond the scope of this article, but
basically it has methods that enable or disable the next and back
buttons based on the user's current position in the wizard pageflow.<br>
<h3>Including the buttons in your UI<br>
</h3>
The component is included in the UI via the &lt;jsp:include&gt;
feature.&nbsp; For each of the pages in the example app, you will see
the following line at the bottom:<br>
<pre>&nbsp;&nbsp;&nbsp; &lt;jsp:include page="wizard-buttons.jsp"/&gt;<br></pre>
Looking at this page, we see it has the following markup:<br>
<pre>&lt;%@ page contentType="text/html" language="java" %&gt;<br>&lt;%@ taglib prefix="f" uri="http://java.sun.com/jsf/core" %&gt;<br>&lt;%@ taglib prefix="h" uri="http://java.sun.com/jsf/html" %&gt;<br><br>&lt;f:subview id="wizard-buttons"&gt;<br><br>  &lt;h:panelGrid columns="2"&gt;<br><br>    &lt;h:commandButton value="&lt; Back" action="back" <br>                     disabled="#{wizardButtons.hasBack}" /&gt;<br><br>    &lt;h:commandButton value="#{wizardButtons.nextLabel}" action="next" <br>                     disabled="#{wizardButtons.hasNext}"/&gt;<br><br>  &lt;/h:panelGrid&gt;<br><br>&lt;/f:subview&gt;<br></pre>
It's important to note that any JSF components that reside in an
included page must be the children of a &lt;f:subview&gt; tag, just as
in the parent page they must be children of the &lt;f:view&gt;
tag.&nbsp; Also, this example doesn't show it, but any template markup
text that you want to include in a subview must be wrapped inside of an
&lt;f:verbatim&gt; tag.&nbsp; You can see that this page just has a
panel grid that lays out two buttons next to eachother.&nbsp; The
attributes for these buttons are tightly bound to the methods and
properties exposed on the wizardButtons bean.&nbsp; These buttons and
the bean are designed to work together.&nbsp; The back button has its
value and action hardcoded.&nbsp; The next button gets its value from
the wizardButtons bean, and has its action hardcoded.&nbsp; <br>
<h3>The Navigation Rules<br>
</h3>
The navigation rules are at the heart of the wizard component.&nbsp;
These rules must be included in the app's faces-config.xml file.&nbsp;
Here is a subset of the rules for this particular application.&nbsp;
You can use these rules as a starting point for leveraging the wizard
component in your own application.<span style="font-family: monospace;"><br>
</span>
<pre><span style="font-family: monospace;"></span>&lt;navigation-rule&gt;</pre>
<pre><code>    &lt;from-view-id&gt;/main.jsp&lt;/from-view-id&gt;<br>    &lt;navigation-case&gt;<br>      &lt;description&gt;<br>        If the action returns "next", goto<br>        firstSelection.jsp<br>      &lt;/description&gt;<br>      &lt;from-outcome&gt;next&lt;/from-outcome&gt;<br>      &lt;to-view-id&gt;/firstSelection.jsp&lt;/to-view-id&gt;<br>    &lt;/navigation-case&gt;<br>  &lt;/navigation-rule&gt;<br><br>  &lt;navigation-rule&gt;<br>    &lt;from-view-id&gt;/firstSelection.jsp&lt;/from-view-id&gt;<br>    &lt;navigation-case&gt;<br>      &lt;description&gt;<br>        If the action returns "next", goto<br>        secondSelection.jsp<br>      &lt;/description&gt;<br>      &lt;from-outcome&gt;next&lt;/from-outcome&gt;<br>      &lt;to-view-id&gt;/secondSelection.jsp&lt;/to-view-id&gt;<br>    &lt;/navigation-case&gt;<br>    &lt;navigation-case&gt;<br>      &lt;description&gt;<br>        If the action returns "back", goto<br>        main.jsp<br>      &lt;/description&gt;<br>      &lt;from-outcome&gt;back&lt;/from-outcome&gt;<br>      &lt;to-view-id&gt;/main.jsp&lt;/to-view-id&gt;<br>    &lt;/navigation-case&gt;<br><br>  &lt;/navigation-rule&gt;<br></code></pre>
In this example if the action invoked from the "main.jsp" page
returns
the "next" outcome then the Navigation Handler will render the
"firstSelection.jsp" page.&nbsp; If the action invoked from the
"firstSelection.jsp" page returns the "back" outcome, we go back to the
main page.&nbsp; If the action invoked returns "next" we go to the
"secondSelection.jsp" page.<br>
<h2>Actions<br>
</h2>
<p>As you recall from the workflow diagram, the first page is special
in that the workflow can cause the page to be reloaded.&nbsp; This
happens when the user wants to add characters to the character
table.&nbsp; This addition is implemented by placing a button in the
page that causes the appropriate action to take place when the button
is pressed.</p>
<p>On the "main.jsp" page, you'll see this button declaration:<br>
</p>
<pre>      &lt;h:commandButton actionListener="#{modelBean.addCustomName}" value="Add Name"/&gt;<br></pre>
<p></p>
<p>The actual Action Handler implementation is in the ModelBean.java
file. The "addCustomName" method adds the name to the table.<br>
</p>
<pre>    public void addCustomName(ActionEvent event) throws AbortProcessingException {<br>        if ((customName != null) &amp;&amp; (!customName.trim().equals(""))) {<br>            customName = customName.trim();<br><br>            //check to see if name already exists in list<br>            Iterator iter = dataList.iterator();<br>            while (iter.hasNext()) {<br>                CharacterBean item = (CharacterBean) iter.next();<br>                if (item.getName().equals(customName)) {<br>                    select();<br>                }<br>            }<br><br>            //create new entry<br>            CharacterBean item = new CharacterBean();<br>            item.setName(customName);<br>            item.setSpecies((SpeciesBean) <br>                speciesPropertyMap.get(customSpecies));<br>            dataList.add(item);<br>        }<br>    }<br><br></pre>
<p></p>
<p>Building the Application
</p>
<p>jmh: NOTE: write simple build.xml and build.properties.sample file
to
use within SJSAS env</p>
<p> Deployment Descriptor
</p>
<p> In order to use the JavaServer Faces framework you need to define
your Faces Servlet and a Faces Servlet Mapping in your Deployment
Descriptor. Here is an example:
</p>
<pre><code><br>    &lt;!-- Faces Servlet --&gt;<br>    &lt;servlet&gt;<br>	   &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;<br>	   &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;<br>	   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br>    &lt;/servlet&gt;<br><br><br>    &lt;!-- Faces Servlet Mapping --&gt;<br>    &lt;servlet-mapping&gt;<br>	   &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;<br>	   &lt;url-pattern&gt;/faces/*&lt;/url-pattern&gt;<br>    &lt;/servlet-mapping&gt;<br><br></code></pre>
<p>In this example prefix mapping is used. You can also map to the
Faces
Servlet using extension mapping. For instance you can make all "*.jsf"
files go through the Faces Servlet controller.
</p>
<p> Application Configuration
</p>
<p> All of your JSF specific configuration information will go in an
application configuration file like faces-config.xml. Here you can
define your Managed Beans, Navigation Rules, Converters, Validators,
and so on.
</p>
<p>Here is an example of some configurations:
</p>
<pre><code><br>&lt;faces-config&gt;<br><br>  &lt;managed-bean&gt;<br>    &lt;managed-bean-name&gt;modelBean&lt;/managed-bean-name&gt;<br>    &lt;managed-bean-class&gt;characterCombat.ModelBean&lt;/managed-bean-class&gt;<br>    &lt;managed-bean-scope&gt;session&lt;/managed-bean-scope&gt;<br>  &lt;/managed-bean&gt;<br><br>&lt;/faces-config&gt;<br></code></pre>
<p>Running the Application
</p>
<p>The latest Java Server Faces 1.0 Framework is integrated in the Sun
Java Systems Application Server 8.0 PE. In SJSAS 8.0 PE you do not need
to take any extra configuration steps to setup a JSF web application
other than specifying the Faces Servlet and Mapping in your web
application's deployment descriptor. SJSAS 8.0 PE is free and available
here </p>
<p>jmh: INSERT LINK </p>
.
<p>In order to run the sample application discussed in this article,
simply
deploy the supplied war file in the application server. The application
will be available by the context name "jsf-characterCombat".
</p>
<p>Summary
</p>
<p>This article has introduced you to some of the features available in
the
JSF framework. The sample application demonstrated the use of
stylesheets, components, navigation and action handlers.
</p>
<p>JSF can help you create complex and robust web applications easily.
It
is a standard Java web application framework several years in the
making. As a standard it is well positioned to be adopted by users and
tool vendors. JSF is a tool that can help you build a great web
application.
</p>
</body>
</html>
