This README documents the Sun Reference implementation (RI) for JSR 127,
JavaServer (tm) Faces.

jsf-api cvs tag for this implementation: JSF_API_20031110_BETA
jsf-api-spec for this implementation: <JSF_SPEC_PFD.pdf>

Installation Notes
==================

JavaServer (tm) Faces is intended to run in a Servlet 2.3, JSP 1.2 web
container, such as that distributed with Java Web Services Developer
Pack <http://java.sun.com/webservices/webservicespack.html>.  Please
follow the instructions for your container and have it working well in
your environment before continuing with these installation notes.

To use JavaServer (tm) Faces in your own webapp, you need to follow the
online documentation at <http://java.sun.com/j2ee/javaserverfaces/>.
Make sure to include all the jars in the lib directory of this
distribution in your WEB-INF/lib directory in your webapp.  

Major changes/features in this release:
=======================================

There have been many changes since the EA4 release of JavaServer
technology. Here are the major ones that really stand out.  Section
numbers refer to the spec.

UIComponent Hierarchy Shuffling
===============================

The component hierararchy has changed a bit, again.

Please see Chapter 3 "User Interface Component Model". Section 4.1
"Standard User Interface Components" includes a diagram of the component
package.  

Note that we have introduced five "behaviorial" interfaces as described
in this table:

interface name	behavioral purpose
ActionSource	implemented by components that can emit ActionEvents

NamingContainer implemented by components that require all their
                children to be named uniquely

StateHolder	implemented by components and other objects that need to 
                save and restore their state between requests

ValueHolder	implemented by components that have a value

ConvertibleValueHolder	implemented by component that have a value that 
                        is subject to type conversion


These interfaces encapsulate the various behaviors of the classes.

Bypass validation and model updates
===================================

It is now possible to cause the page submit to bypass the validation and
model update phases by setting the "immediate" property of UICommand
which causes the page submit to be true. This is useful for situations
such as "cancel" buttons.

Please see Section 3.2.1.1 "Properties".

Concrete HTML component classes
===============================

To enable tools to deliver "component pallete" type interfaces, a new
package of UIComponent subclasses has been introduced. These componets
simply combine the notion of component and renderer for all the
supported combinations of component and renderer.

Please Section 8.6 "The concrete HTML component classes".

Flexible way to map to FacesServlet
===============================

It is no longer required to use /faces/* as the url-mapping for faces
webapps. You can now use any prefix or extension mapping.

Please see Section 10.1.2 "Servlet Mapping".

ResopnseWriter changes
======================

Most of the methods on the ResponseWriter class now take an additonal
argument that will allow tool vendors to gain information at design time
about the correspondence between page elements and UIComponent
instances.

Please see Section 6.1.6 "ResponseStream and ResponseWriter".

New value binding mechanism
===========================

Nearly all component properties can now be either a literal value, or
get their value from a ValueBinding. This enables lots of flexibility
for configuring your components. Here’s a JSP example:

<h:input_text value="default value" />

<h:output_text value="#{requestScope.username}" />

<h:command_button value="#{localizedBundle.buyLabel}" />

The first shows a literal value, the second looking into the scoped
namespace with the requestScope implicit object, and the third using the
cascading lookup mechanism to find a bean that answers to the name
localizedBundle.

We no longer have two separate attributes, value and valueRef, just one
value attribute that serves both purposes. We have also introduced a new
delimiter syntax #{}. This was necessary to prevent the JSP 2.0 page
engine from interpreting the expression before we it made sense to do
so.

Please see Section 5.1 "Value Binding Expressions".

New method binding mechanism
============================

It is now possible to refer directly to a method in a JavaBean
accessible in the scoped namespace for things like button press events,
and value change events. The following attributes accept method binding
expressions

action

actionListener

validate

valueChangeListener

Please see Section 5.2 "Method Binding Expressions".

Component reference mechanism
=============================

It is now possible to have the components in the view reside as
properties of an arbitrary JavaBean. This would be useful, combined with
the aforementioned value and method binding mechanims, if you wanted to
have a JavaBean that stands behind each page in your webapp. Here's a
couple of JSP examples:

  <h:selectone_menu styleClass="optionValue"
                       binding="#{carstore.currentModel.engine}"/>

  <h:command_button binding="#{carstore.buyButton}"
                     action="#{carstore.curBuyAction}"/>

Here we are saying that the actual UISelectOne instance that stands
behind this menu widget in the page is returned by invoking the
getEngine() method on the bean returned by evaluating the expression
carstore.currentModel and that the actual UICommand component is
returned from the getBuyButton() method of that same bean.  If the
getter method returns null, the tag will create a component instance
(as usual) and call your setter method.  With either alternative, you
can now manipulate the component instance programmatically in your
backing bean.

Please see Section 3.1.3 "Component Reference Expressions".

Maps and Lists in the faces-config file
=======================================

It is now possible to have java.util.Map and java.util.List entries
directly as managed beans in the faces-config file. It is also possible
to configure these entities with the existing configuration syntax.

Please see Section 5.3.1.2 "Default VariableResolver Implementation".

State Saving mechanism
======================

We provide automated saving of the component state between requests. The
application author can choose to have the state saved in the client or
on the server. The mechanism supports having multiple forms in the page,
but having the state of the entire page be restored.

Please see Section 2.5.2 "State Management".

Including JSP pages with <jsp:include> or <c:import>
====================================================

It is now possible to include JSP pages using either of the above tags.

Please see Section 9.5.7 "<f:subview>".

Localization mechanism
======================

We now support ResourceBundle based localization for all component
attributes. In addition, we conform to JSP, JSTL, and Servlet best
practices for character encoding and Locale support.

Please see Section 2.5.1 "Localization and Internationalization
(L10N/I18N)".

Adapter pattern for pluggable Factory classes
=============================================

Several classes in the API have always been pluggable by providing a
factory for those classes. It is now possible to have the pluggable
imelementation get access to the previously installed
implementation. This allows one to override just a subset of the
functionality, without having to subclass or re-implement
everything. Please see the javadocs for the javax.faces.FactoryFinder
class.

New hyperlink component/renderer combinations
=============================================

The <h:command_hyperlink> tag has been replaced by the <h:output_link>
and <h:command_link> tags. The former is for linking to other pages
without doing a post back. The latter is just like a <h:command_button>
except that the label comes from nested content, and the result shows up
to the user as a hyperlink.

Please see Section 8.5.1 "Renderer Types for UICommand Components" and
Section 8.5.6 "Renderer Types for UIOutput Components".

Event mechanism implementation changes
======================================

Most of the event firing and litener invocation mechanism is implemented
in the API classes. This implementation has changed dramatically since
EA4, but there is minimal change on the usage model.

Also, any occurrence of valuechanged, as in valuechanged-listener,
ValueChangedListener, etc has been changed to valuechange. That is,
there is no "ed". This is for parity with JavaBeans.

Please see Section 3.4.7 "Event Broadcasting".

New UIData component and Table Renderer
=======================================

This release introduces a powerful, flexible, way to show data in a
Table given a number of data sources.

Please see Section 4.1.3 "UIData" and Section 8.5.2 "Renderer Types for
UIData Components".There have been many changes since the EA4 release of
JavaServer technology. Here are the major ones that really stand out.

Logging support and configuration steps
=======================================
JavaServer Faces Reference Implementation in this release leverages the 
Jakarta Commons logging API to provide logging functionality. We have followed 
the guidelines recommended by 
http://jakarta.apache.org/commons/logging/userguide.html.
JavaServer Faces Reference Implementation can be configured to provide
logging information using the steps below.

step 1.
If you are using Tomcat or JWSDP as your container, you can set the following 
property to tell the container what logging implementation you are using
as well as the location of your logging configuration file. 
set CATALINA_OPTS=-Dorg.apache.commons.logging.Log=org.apache.commons.logging.impl.Jdk14Logger -Djava.util.logging.config.file=D:\Files_2k\j2sdk1.4.1_03\jre\lib\jsf-log.properties

step 2.
We have shown a sample logging configuration file below that is configured to
get logging output when you are running a JavaServer Faces application. 
The default JDK 1.4 logging configuration file is 
"$JAVA_HOME}/jre/lib/logging.properties". You can either manipulate that as per
directions below, in which case it's global to all Java apps that you run
or you can create a jsf.log properties as illustrated below. You can change 
the "java.util.logging.FileHandler.pattern" property to control
where your logging information is written.

Here's the jsf-log.properties
############################################################
#  	Default Logging Configuration File
# http://java.sun.com/j2se/1.4.2/docs/guide/util/logging/overview.html#1.2
# You can use a different file by specifying a filename
# with the java.util.logging.config.file system property.  
# For example java -Djava.util.logging.config.file=myfile
############################################################

############################################################
#  	Global properties
############################################################

# "handlers" specifies a comma separated list of log Handler 
# classes.  These handlers will be installed during VM startup.
# Note that these classes must be on the system classpath.
# By default we only configure a ConsoleHandler, which will only
# show messages at the INFO and above levels.

# To also add the FileHandler, use the following line instead.
handlers= java.util.logging.FileHandler, java.util.logging.ConsoleHandler

# Default global logging level.
# This specifies which kinds of events are logged across
# all loggers.  For any given facility this global level
# can be overriden by a facility specific level
# Note that the ConsoleHandler also has a separate level
# setting to limit messages printed to the console.
#.level= INFO
.level= INFO

############################################################
# Handler specific properties.
# Describes specific configuration info for Handlers.
############################################################

# default file output is in user's home directory.
java.util.logging.FileHandler.pattern = %h/java%u.log
java.util.logging.FileHandler.limit = 50000
java.util.logging.FileHandler.count = 1
java.util.logging.FileHandler.formatter = java.util.logging.XMLFormatter

# Limit the message that are printed on the console to INFO and above.
java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter


############################################################
# Facility specific properties.
# Provides extra control for each logger.
############################################################

# For example, set the com.xyz.foo logger to only log SEVERE
# messages:
com.xyz.foo.level = SEVERE
com.sun.faces.level = ALL

If you use the ConsoleHandler ( which would direct all the output to catalina.out 
in the case of standalone Tomcat or launcher.server.log in the case of JWSDP )
please make sure that the detail level for ConsoleHandler can handle the level set
for individual packages. For example say you have set the level for 
"com.sun.faces.el" package to "FINEST" as below.
    "com.sun.faces.el.level = FINEST"

You won't see any trace or debug messages unless you also set 
ConsoleHandler.level = FINEST. ConsoleHandler.level caps the detail level to the 
console, no matter what the underlying loggers are set for.

In this release, the Reference Implementation provides logging support for the
following packges.
    * com.sun.faces.application
    * com.sun.faces.el
    * com.sun.faces.lifecycle

The logging messages are not localized. Localisation as 
well as logging for rest of the RI will be done in a future release.

Known Issues With This Release
==============================

* When deploying on a non-JWSDP container, you must include all the
  dependent jars in your webapp's WEB-INF/lib directory.  It's possible
  it may work without doing this, but this is not a supported
  configuration.

* If you're using a tomcat 4 series container, you must use JSTL 1.0
  instead of JSTL 1.1.

* UIData children that do not use VB expressions fail to maintain their
  values.  In other words, if you have a literal value in a child of a
  UIData component, that value will be lost on postback.  Workaround:
  always use a VB expression with the value attribute for UIData
  children.

* UIComponent.broadcast() fails to throw IllegalStateException if passed
  invalid Parameter.

  From the javadocs of UIComponent.broadcast():

  <quote> java.lang.IllegalStateException - if PhaseId.ANY_PHASE is
  passed for the phase identifier </quote>

  No exception is currently thrown by the RI.

* UIInput.validate() does not store zero-length String into previous property.

* Incorrect type conversion for UISelectMany

  This class doesn't properly deal with conversion for primitives.
  Workaround: use wrapper classes instead of primitives for model objects.

* <h:message> ignores locale set in <f:view>

    My system locale is French and if I do this...
    <f:view locale='en'>

        <h:output_text value='#{msgs.namePrompt}'/>
        <h:input_text id='name' value='#{user.name}'/>

        <h:message for='name'/>

    </f:view>

    <h:output_text> retrieves its output from my English resource bundle
    (as it should), but <h:message> stubbornly produces its error message
    in French (as it should not).

* Renderers in the Standard HTML RenderKit are fragile in terms of their
  support for rendered="false" on children and facets.  Specific known issues
  include:
  - GridRenderer emits <td></td> for a child component that is
    set to rendered="false".
  - TableRenderer ignores rendered="false" on child UIColumn components.
  - All renderers that deal with facets are currently ignoring rendered=false
    on the facet components.

* The non-jsp demo does not deploy under tomcat 4.1.29.  

* Some web containers don't follow the Servlet 2.3 Spec rule of calling
  ServletContextListeners listeners defined in tld files in the META-INF
  directory of a jar. Running a faces webapp in such a container
  requires you to manually declare the ServletContextListener.  The
  listener-class you need to specify is

  com.sun.faces.config.ConfigListener




Legal Notice
============

Copyright © 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa
Clara, California 95054, U.S.A. All rights reserved.

Sun Microsystems, Inc. has intellectual property rights relating to
technology embodied in this product. In particular, and without
limitation, these intellectual property rights may include one or more
of the U.S. patents listed at http://www.sun.com/patents and one or more
additional patents or pending patent applications in the U.S. and other
countries.

This product is distributed under licenses restricting its use, copying
distribution, and decompilation. No part of this product may be
reproduced in any form by any means without prior written authorization
of Sun and its licensors, if any.

Third-party software, including font technology, is copyrighted and
licensed from Sun suppliers.

Sun, Sun Microsystems, the Sun logo, the Java Coffee Cup logo,
JavaServer, and Java are trademarks or registered trademarks of Sun
Microsystems, Inc. in the U.S. and other countries.

Federal Acquisitions: Commercial Software - Government Users Subject to
Standard License Terms and Conditions.

-----------------------------------------------------------------------

Copyright © 2002 Sun Microsystems, Inc., 4150 Network Circle,
Santa Clara, California 95054, Etats-Unis. Tous droits réservés.

Sun Microsystems, Inc. a les droits de propriété intellectuels relatants
à la technologie incorporée dans ce produit. En particulier, et sans la
limitation, ces droits de propriété intellectuels peuvent inclure un ou
plus des brevets américains énumérés à http://www.sun.com/patents et un
ou les brevets plus supplémentaires ou les applications de brevet en
attente dans les Etats - Unis et les autres pays.

Ce produit ou document est protégé par un copyright et distribué avec
des licences qui en restreignent l'utilisation, la copie, la
distribution, et la décompilation. Aucune partie de ce produit ou
document ne peut être reproduite sous aucune forme, par quelque moyen
que ce soit, sans l'autorisation préalable et écrite de Sun et de ses
bailleurs de licence, s'il y ena.

Le logiciel détenu par des tiers, et qui comprend la technologie
relative aux polices de caractères, est protégé par un copyright et
licencié par des fournisseurs de Sun.

Sun, Sun Microsystems, le logo Sun, le logo Java Coffee Cup, JavaServer,
et Java sont des marques de fabrique ou des marques déposées de Sun
Microsystems, Inc. aux Etats-Unis et dans d'autres pays.
