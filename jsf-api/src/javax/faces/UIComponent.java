/*
 * $Id: UIComponent.java,v 1.11 2002/03/20 00:34:11 jvisvanathan Exp $
 */

/*
 * Copyright 2002 Sun Microsystems, Inc. All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package javax.faces;

import java.io.IOException;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Set;
import java.util.Vector;
import javax.servlet.ServletRequest;
import java.io.InputStream; //temporary
import java.io.OutputStream; //temporary

/**
 * The base class for JSF user-interface components.  
 * A UI component is the basic building block for creating
 * a JSF user-interface for a web application.  
 * <p>
 * A user-interface is created by assembling UI components into
 * a UI component tree where each node in the tree is an instance
 * of UIComponent.  The root of the tree is a UIPage component.
 * <p>
 * A JSF request is a request for a resource (JSF page) which contains
 * a UI component tree.  JSF processes each request by
 * executing the following well-defined sequence:
 * <ol>
 * <li>wireUp: the process of converting a JSF UI definition into
 *             its associated UI component tree
 * <li>executeLifecycle: executing a well defined lifecycle on
 *             the UI component tree
 * </ol>
 * This sequence is encapsulated in the LifecycleDriver interface.
 * 
 * <h3>Using JSF in JSP Pages</h3>
 * JSP may be used as the page description language for JSF pages.
 * Such JSP pages should extend the FacesHttpJspPage base class.
 * A JSP page would use JSF component custom tags to layout
 * the UI component tree within the content of the JSP.  The
 * FacesHttpJspPage base class takes responsibility for invoking
 * a LifecycleDriver object which drives the wireUp and executeLifecycle
 * phases.  The page author only needs to extend the base class and 
 * include the desired JSF component tags to define the user interface.
 *
 * <h3>Using JSF without JSP</h3>
 * A JSF page may be created without relying on JSP by creating
 * a Servlet which invokes the LifecycleDriver object from its
 * service() method.
 *
 * <h3>UI Lifecycle</h3>
 * Each Faces request is processed by executing the following
 * well defined lifecycle on the page's UI component tree:
 * <ol>
 * <li>init: invoked as the component is instantiated
 * <li>restoreState: any UI component state which was saved
 *     in a prior request for the page (see saveState) is
 *     restored on those components
 * <li>applyNewValues: any UI component values which were
 *     generated on the client as part of the postback are 
 *     set on the components
 * <li>processEvents: any events generated by the client
 *     are dispatched to components, invoking any registered
 *     event handling;  this may trigger validation.  
 * <li>preRender: invoked on each component after all events 
 *     have been processed and if flow has not been redirected
 *     elsewhere, allowing components to prepare for rendering.
 *     This is the last phase where UI component state may be
 *     modified.
 * <li>saveState: any UI component state which must be preserved
 *     across requests is saved (if &quot;saveState&quot; attribute
 *     is true)
 * <li>render: each UI component in the tree is rendered (if
 *     &quot;shouldRender&quot; attribute is true), starting from
 *     the root
 * <li>dispose: invoked on each component after all rendering is 
 *     complete, but before the UI component tree is garbage
 *     collected, allowing any cleanup to be performed
 * </ol>
 * A particular UI component subclass may implement additional
 * lifecycle stages where appropriate, however the above stages
 * are required.
 *
 * PENDING(aim): in the next rev, all RenderContext params should
 * be replaced with FacesContext
 */
public abstract class UIComponent {
 
    private Hashtable ht;
    private Vector children = null;
    private String id;
    private String rendererType;
    private String modelReference = null;

    public UIComponent() {
        ht = new Hashtable();
        children = null;
    }

    private void lazilyCreateChildren() {
        if (null == children) {
            children = new Vector();
        }
    }

    /** 
     * Returns a String representing the type of this concrete
     * component class.  This read-only property is used by the RenderKit
     * instance as the key for mapping a component type to its 
     * available renderers.  A concrete subclass must return a
     * String value which is descriptive of the functional purpose 
     * of the component.
     *
     * @return a String representing the component's functional type
     *         
     */

    // PENDING(edburns): Spec Compliance: instance into Scoped Namespace
    // per spec:
    // http://javaweb.sfbay.sun.com/~aim/faces/jsr-127-archive/msg00124.html
    // section "Configuring UI Components"

    public abstract String getType();

    /**
     * The id which identifies this component instance within its
     * UI component tree.
     * PENDING(aim): This will be replaced in the next rev with:
     * The id which identifies this component instance locally within
     * its nearest NamingContainer ancestor.  This id may be assigned
     * by the application at the time this component is initialized.
     * If the application does not provide an id, the Faces framework
     * will automatically generate one.
     * @see #setId
     * @return String containing the id of this component
     */
    public String getId() {
	return id;
    }

    /**
     * Sets the id of this component.
     * @see #getId
     * @param id String containing the id of the component
     */
    public void setId(String id) {
	this.id = id;
    }

    /**
     * PENDING(aim):to be added in next rev:
     * The id which uniquely identifies this component within its
     * UI component tree.  This unique id is composed by prepending
     * this component's id with the concatonation of the ids of all 
     * NamingContainer ancestors, each id being separated by an 
     * underscore ('_') character.
     * @return String containing the unique id of this component
     
    public String getUniqueId() {
    }
    */

    /**
     * The renderer type to be used to render this component.
     * If this attribute has a null value when <code>render()</code>
     * is invoked on this component, this component must be responsible
     * for generating the rendered output.  If this attribute is non-null
     * when <code>render()</code> is invoked, then the value of 
     * this property must match one of the advertized renderer types on the 
     * renderkit specified in the faces context.
     * @see RenderKit#getRendererTypesForComponent
     * @see #render
     * @return String containing the type of the renderer set for
     *         this component
     */
    public String getRendererType() {
	return rendererType;
    }

    /**
     * Sets the renderer type to be used to render this component.
     * @see #getRendererType
     * @param rendererType String containing the type of the renderer
     */
    public void setRendererType(String rendererType) {
        this.rendererType = rendererType;
    }
 
    /**
     * Returns an iterator containing all the attribute names
     * corresponding to attributes set specifically on this
     * component within the specified render context.
     *
     * @param rc the render context used to render this component
     * @return an Iteration of attribute names on this component
     */   
    public Iterator getAttributeNames(RenderContext rc) {
        Set set = ht.keySet();
        if (set.isEmpty()) {
            return null;
        } else {
            return set.iterator();
        }
    }

    /**
     * Returns the component attribute with the given name
     * within the specified render context or null if the
     * specified attribute is not set on this component.
     *
     * @param rc the render context used to render this component
     * @param attributeName a String specifying the name of the attribute
     * @return the Object bound to the attribute name, or null if the
     *          attribute does not exist.
     */
    public Object getAttribute(RenderContext rc, String attributeName) {
        return ht.get(attributeName);
    }

    /**
     * Binds an object to the specified attribute name for this component.
     *
     * @param attributeName a String specifying the name of the attribute
     * @param value an Object representing the value of the attribute
     */
    public void setAttribute(String attributeName, Object value) {
        if (attributeName != null && value != null) {
            ht.put(attributeName,value);
        }
        else if (null != attributeName && null == value) {
            ht.remove(attributeName);
        }
    }

    /**
     * Adds the specified component as a child to this component.
     * The child will be added at the end of this component's sequence
     * of children.
     * @param child the UIComponent to be added as a child
     * @throws NullPointerException if child is null
     */
    public void add(UIComponent child) {
        lazilyCreateChildren();
        children.add(child);
    }

    /**
     * Adds the specified component as a child to this component at
     * the specified index.
     * @param child the UIComponent to be added as a child
     * @param index the integer indicating where in the sequence of
     *        children the child should be added
     * @throws NullPointerException if child is null
     * @throws IndexOutOfBoundsException if index < 0 or index > childCount
     */
    public void add(UIComponent child, int index) {
        lazilyCreateChildren();
        children.insertElementAt(child, index);
    }

   /**
     * Adds the specified component as a child to this component with
     * the specified childMarker.  The childMarker is an arbitrary Object
     * which may be used internally by this parent component to associate
     * information with this child.  
     *
     * @param child the UIComponent representing the child to be added
     * @param childMarker an Object which is associated with the child within
     *        this parent component
     * @throws NullPointerException if child is null
     */ 
    public void add(UIComponent child, Object childMarker) {}

    /** 
     * Removes the child component located at the specified index from
     * this component.
     * @param index the integer indicating the index of the child to be 
     *        removed 
     * @throws IndexOutOfBoundsException if index < 0 or index > childCount-1
     */ 
    public void remove(int index) {
        children.removeElementAt(index);
    }

    /**
     * Removes all child components from this component.
     */
    public void removeAll() {
        children.removeAllElements();
    }

    /**
     * Sets the child components on this component to be the specified 
     * array of components.  If this component already contains children at
     * the time this method is invoked, they will be removed by invoking
     * <code>removeAll</code> before the new children are added.
     * @param kids the array containing the components to add as children
     * @throws NullPointerException if kids is null
     */
    public void setChildren(UIComponent[] kids) {
        if ( children != null ) {
            removeAll();
        } else {
            lazilyCreateChildren();
        }    
        for ( int i = 0; i < kids.length; ++i ) {
            children.add(kids[i]);
        }    
    }

    /**
     * Returns an iterator containing all the children of this component
     * for the specified render context.  
     * @param rc the render context used to render this component, or null
     */
    public Iterator getChildren(RenderContext rc) {
        lazilyCreateChildren();
        return children.iterator();
    }

    /**
     * Returns an iterator containing Strings representing the ids
     * of all children of this component for the specified render context.
     * @param rc the render context used to render this component, or null
     */
    public Iterator getChildIds(RenderContext rc) {
        Vector childIds = new Vector();
        Iterator iterator = getChildren(rc);
        while ( iterator.hasNext() ) {
            UIComponent child = (UIComponent) iterator.next();
            childIds.add(child.getId());
        }
        return childIds.iterator();
    }

    /**
     * Returns an iterator containing child marker objects associated with
     * children of this component for the specified render context.
     * @param rc the render context used to render this component, or null
     */
    public Iterator getChildMarkers(RenderContext rc) {
        return null; //compile
    }

    /**
     * Returns the child at the specified index in this component
     * for the specified render context.
     * @param rc the render context used to render this component, or null
     * @param index the integer indicating the index of the child
     * @throws IndexOutOfBoundsException if index < 0 or index > childCount-1
     */
    public UIComponent getChild(RenderContext rc, int index) {
        UIComponent child = null;
        return (UIComponent)children.elementAt(index);
    }

    /**
     * Returns the child with the specified id, or null if no child
     * with that id exists.
     * @param rc the render context used to render this component, or null
     * @param id a String containing the id of the child being retrieved
     * @throws NullPointerException if id is null
     */
    public UIComponent getChild(RenderContext rc, String id) {
        UIComponent child = null;
        Iterator iterator = getChildren(rc);
        while ( iterator.hasNext() ) {
            child = (UIComponent) iterator.next();
            if ( child.getId().equals( id )) {
                break;
            }
        }
        return child;
    }

    /**
     * Returns the number of children in this component for the
     * specified render context.
     * @param rc the render context used to render this component, or null
     * @return an integer indicating the number of children in this
     *          component.
     */
    public int getChildCount(RenderContext rc) {
        int size = 0;
        if ( children != null ) {
            size = children.size();
        }
        return size;
    }

    /**
     * Invoked during the &quot;init&quot; lifecycle phase.  A concrete
     * subclass should override this method if it must perform any
     * initialization steps before the other lifecycle phases execute.
     * @param ctx the FacesContext object used to process the current request
     */
    public void init(FacesContext ctx) {
    }

    /**
     * Invoked during the &quot;restoreState&quot; lifecycle phase to
     * restore any component state saved during the &quot;saveState&quot;
     * phase of a prior request.  A concrete subclass should override
     * this method if it must perform any state restoration.
     * @see #saveState
     * @param ctx the FacesContext object used to process the current request
     * @param is PENDING(aim): need to define IS subclass?
     */
    public void restoreState(FacesContext ctx, InputStream is) {
    }

    /**
     * Invoked during the &quot;preRender&quot; lifecycle phase.
     * A concrete subclass should override this method if it must perform
     * any processing after event-processing but before rendering.
     * @param ctx the FacesContext object used to process the current request
     */
    public void preRender(FacesContext ctx) {
    }

    /**
     * Invoked during the &quot;saveState&quot; lifecycle phase if
     * the &quot;shouldSaveState&quot; attribute is <code>true</code>.
     * A concrete subclass should override this method if it must save
     * any component state across requests.
     * @param ctx the FacesContext object used to process the current request
     * @param os PENDING(aim): need to define OS subclass?
     */
    public void saveState(FacesContext ctx, OutputStream os) {
    }

    /**
     * Invoked on each component after all rendering is
     * complete, but before the UI component tree is garbage
     * collected, allowing any cleanup to be performed
     * @param ctx the FacesContext object used to process the current request
     */
    public void dispose(FacesContext ctx) {
    }

    /**
     * The &quot;shouldSaveState&quot; attribute which defines whether
     * or not the state on this component instance should be saved
     * across requests during the &quot;saveState&quot; lifecycle phase
     * and restored on subsequent postbacks during the &quot;restoreState&quot;
     * lifecycle phase.  
     * Returns <code>true</code> by default.  
     * @see #setShouldSaveState
     * @see #saveState
     * @see #restoreState
     * @param ctx the FacesContext object used to process the current request
     * @return boolean value indicating whether or not the state of this
     *         component should be saved across requests.
     */
    public boolean getShouldSaveState(FacesContext ctx) {
	return true;
    }

    /**
     * Sets the &quot;shouldSaveState&quot; attribute. 
     * @see #getShouldSaveState
     * @param saveState 
     *   boolean value indicating whether or not the state of this
     *   component should be saved across requests.
     */
    public void setShouldSaveState(boolean saveState) {
    }


    /**
     * The &quot;rendersChildren&quot; attribute.  Returns <code>false</code>
     * by default.  A concrete subclass which supports the ability to
     * drive the layout and rendering of children should override this
     * method to return <code>true</code>.
     * @param rc the render context used to render this component, or null
     * @return boolean value indicating whether or not this component
     *         takes responsibility for laying out and rendering its
     *         children.
     */
    public boolean getRendersChildren(RenderContext rc) {
	return false;
    }

   /**
    * The &quot;shouldRender&quot; attribute. 
    * @see #setShouldRender
    * @see #render 
    * @return a boolean value indicating whether or not this component 
    *         and its descendents should be rendered during the
    *         &quot;render&quot; lifecycle phase
    */
    public boolean getShouldRender(RenderContext rc) {
	return true;
    }

    /**
     * Sets the &quot;shouldRender&quot; attribute.  If set to 
     * <code>true</code>
     * this component will be rendered during the render lifecycle phase.
     * If set to <code>false</code>, this component and none of its 
     * descendents will be rendered during the &quot;render&quot; lifecycle 
     * phase.
     * This attribute allows branches of the UI component tree to be
     * dynamically 'hidden' or 'shown'.
     * @see #getShouldRender
     */
    public void setShouldRender(boolean shouldRender) {
    }

    /**
     * Returns whether or not this component is in a renderable UI
     * component branch.
     * A branch is renderable if this component and all it's ancestors
     * have shouldRender set to <code>true</code>.
     * @param rc the render context used to render this component
     * @throws NullPointerException if rc is null
     * @return boolean value indicating whether or not this component is in
     *         a renderable hierarchy
     */
    public boolean isRenderable(RenderContext rc) {
	return true;
    }

    /**
     * Invoked during the &quot;render&quot; lifecycle phase if
     * the &quot;rendersChildren&quot; attribute is <code>true</code>.
     * Invokes full render processing on this component and its
     * descendents, calling the following sequence of methods:
     * <ol>
     * <li>render()
     * <li>renderChildren()
     * <li>renderComplete()
     * </ol>
     * This method will recursively drive the rendering process for
     * this component and all of its descendents, treating the
     * rendering of that branch as an atomic process.  This 
     * method should only be called if the the portion of the user-interface
     * defined by this branch is completely defined by this
     * branch (i.e. no interleaved presentation markup).
     *
     * @see #getRendersChildren
     * @param rc the render context used to render this component
     * @throws NullPointerException if rc is null
     * @throws FacesException if rendersChildren is <code>false</code>
     * @throws IOException if input or output exception occurred
     */
    public void renderAll(RenderContext rc) throws IOException {}

    /**
     * Invoked during the &quot;render&quot; lifecycle phase.
     * Renders this component only and does not perform any rendering
     * on children.  By default, if the &quot;rendererType&quot;
     * attribute is non-null, this method will invoke renderStart()
     * on the corresponding renderer.  If &quot;rendererType&quot;
     * is null, the concrete subclass must take responsibility for
     * rendering the component from this method.
     * @see #getRendererType
     * @param rc the render context used to render this component
     * @throws NullPointerException if rc is null
     * @throws FacesException if rendererType is not set to a valid renderer
     *         in the render context's render kit
     * @throws IOException if input or output exception occurred
     */
    public void render(RenderContext rc) throws IOException,
        FacesException {

        RenderKit rk = rc.getRenderKit();
        String rendererType = getRendererType();
        if (rendererType == null) {
            throw new FacesException("Renderer Type Not Set.");
        }
        Renderer r = rk.getRenderer(rendererType);
        rc.pushChild(this);
        r.renderStart(rc, this);
    }

    /**
     * Invoked during the &quot;render&quot; lifecycle phase to
     * perform rendering of this component's children.  This method
     * is typically called from renderAll() and should only be
     * invoked if the &quot;rendersChildren&quot; attribute is 
     * <code>true</code>.  If &quot;rendersChildren&quot; is
     * <code>false</code>, the concrete subclass should override
     * this method to do nothing.
     * <p> 
     * By default, if the &quot;rendererType&quot; attribute is 
     * non-null, this method will invoke renderChildren() on the  
     * corresponding renderer.  If the &quot;rendererType&quot;
     * attribute is null, the concrete subclass must take responsibility
     * for invoking rendering for each child.
     * @see #renderAll
     * @see #getRendersChildren
     * @param rc the render context used to render this component
     * @throws NullPointerException if rc is null
     * @throws IOException if input or output exception occurred
     */
    public void renderChildren(RenderContext rc) throws IOException {}

    /**
     * Invoked during the &quot;render&quot; lifecycle phase after 
     * this component and all of it's children have been
     * rendered. By default, if the &quot;rendererType&quot;
     * attribute is non-null, this method will invoke renderComplete()
     * on the corresponding renderer.  If &quot;rendererType&quot;
     * is null, the concrete subclass must take responsibility for
     * completion rendering (i.e. end tags) from this method. 
     * 
     * @param rc the render context used to render this component
     * @throws NullPointerException if rc is null
     * @throws IOException if input or output exception occurred
     */
    public void renderComplete(RenderContext rc) throws IOException {
        RenderKit rk = rc.getRenderKit();
        String rendererType = getRendererType();
        if (rendererType == null) {
            throw new FacesException("Renderer Type Not Set.");
        }
        Renderer r = rk.getRenderer(rendererType);
        r.renderComplete(rc, this);
        rc.popChild();
    }

    /**
     * Invokes component-level validation on this component and all
     * of its descendents.  The tree traversal is executed from bottom
     * to top, invoking validate() on each validatible component
     * in the branch.  After this method completes, isValid() may
     * be used to determine whether or not component-level validation
     * succeeded (all components are valid) or failed (one or more
     * components are invalid).
     * @see #isValid
     * @see Validatible 
     * @param ec
     */
    public void validateAll(EventContext ec) {
        // PENDING ( visvan )
        // is it possible to avoid traversing the tree so many times.
        ObjectManager ot = ec.getObjectManager();
        ServletRequest request = ec.getRequest();
        RenderContext rc = (RenderContext)ot.get(request,
                        Constants.REF_RENDERCONTEXT);
        UIComponent child = null;
        Iterator iterator = getChildren(rc);
        while (iterator.hasNext()) {
            child = (UIComponent) iterator.next();
            if ( child != null && child instanceof Validatible ) {
                child.validateAll(ec);
            } 
            if (child instanceof Validatible ) {
                ((Validatible)child).doValidate(ec);
            }   
        }
    }

   /**
    * Will recursively push all component values to model
    * to model if validation succeeded. If validation failed,
    * converts local values to string for rendering. Right we
    * do this only for validatible components. For others, values
    * get pushed during their dispatch method since we haven't
    * implemented them yet.
    *
    * @param ec EventContext object representing the event-processing
    *           phase of this request 
    */
    //PENDING (visvan) check method name with Aim.
    public void pushAllValuesToModel(EventContext ec) {

	ObjectManager objectManager = ec.getObjectManager();
	ServletRequest request = ec.getRequest();
        RenderContext rc = (RenderContext)objectManager.get(request,
                        Constants.REF_RENDERCONTEXT);
	TreeNavigator treeNav = (TreeNavigator) 
	    objectManager.get(request, Constants.REF_TREENAVIGATOR);

	// Assert.assert_it(null != treeNav);
	UIComponent next;
	treeNav.reset();
        if (treeNav.getRoot().isValid(ec)) {
	    while (null != (next = treeNav.getNextStart())) {
                if ( (next instanceof Validatible) ) {
                    next.pushValueToModel(rc);
                    ((Validatible)next).setValidState(Validatible.UNVALIDATED);
                }
            }
        } else {
            while (null != (next = treeNav.getNextStart())) {
                if ( (next instanceof Validatible) ) { 
                    Object value = next.getValue(rc);
                    if ( value != null ) {
                        next.setValue(value.toString());
                    }
                    ((Validatible)next).setValidState(Validatible.UNVALIDATED);
                }
            }
        }
	treeNav.reset();
    }

    /**
     * A component hierarchy is valid when it and all of its descendents are
     * either:
     * <ol>
     * <li>not Validatible 
     * <li>Validatible with <code>validState == Validatible.VALID</code>
     * </ol>
     * @see #validateAll
     * @return boolean value indicating whether this branch of the UI
     *         component tree is valid
     */
    public boolean isValid(EventContext ec ) {

        boolean valid = false;
        UIComponent child = null;

        ObjectManager objectManager = ec.getObjectManager();
        ServletRequest request = ec.getRequest();
        RenderContext rc = (RenderContext)objectManager.get(request,
                        Constants.REF_RENDERCONTEXT);
        TreeNavigator treeNav = (TreeNavigator)
            objectManager.get(request, Constants.REF_TREENAVIGATOR);

        // Assert.assert_it(null != treeNav);
        UIComponent next;
        treeNav.reset();
        while (null != (child = treeNav.getNextStart())) {
            if ( child instanceof Validatible && 
                 ((Validatible)child).getValidState() == Validatible.INVALID) {
                valid = false;
                break;
            } else {
                valid = true;
            }    
        }    
        treeNav.reset();
        return valid;
    }

    /**
     * The model-reference property for this data-bound component.
     * This property contains a reference to the object which acts
     * as the data-source for this component.  The model-reference
     * must resolve to an object which implements one of the following types:
     * <ul>
     * <li><code>java.lang.String</code>
     * </ul>
     * PENDING(aim): this should be moved to ValueComponent subclass.
     * @see #setModelReference
     * @return String containing the model-reference for this component
     */
    public String getModelReference() {
        return modelReference;
    }

    /**
     * Sets the model-reference property on this data-bound component.
     * PENDING(aim): this should be moved to ValueComponent subclass.
     * @see #getModelReference
     * @param modelReference the String which contains a reference to the
     *        object which acts as the data-source for this component
     */
    public void setModelReference(String modelReference) {
        this.modelReference = modelReference;
    }

   /**
    * If localValue is non-null, we just return it.  Else, if we have a
    * model reference, we ask it for a value.  If it does, we cache it
    * in localValue.  Then we return localValue.
     * PENDING(aim): this should be moved to ValueComponent subclass.
    */ 

    public Object getValue(RenderContext rc) {
	Object result = ht.get(Constants.REF_VALUE);
	if (null == result) {
	    result = pullValueFromModel(rc);
	}
        return result;
    }

    /**
     *
     * PENDING(aim): should be moved to ValueComponent subclass (?)
     */   
    public void setValue(Object newValue) {
	setAttribute(Constants.REF_VALUE, newValue);
    }

    /**
    *   If we do not have a modelReference, do nothing.  Else, If
    *   localValue non-null, try to push localValue into model().  If
    *   successful, set localValue to null, else leave localValue alone.
     * PENDING(aim): should be moved to ValueComponent subclass(?)

    */
    public void pushValueToModel(RenderContext rc) {
      
        Object localValue = ht.get(Constants.REF_VALUE); 
	if (null == modelReference) {
            // local value should be converted to String for rendering
            // purposeS
            if ( localValue != null ) {
                setValue(localValue.toString());
            }
	    return;
	}
	if (null != localValue) {
            try {
                rc.getObjectAccessor().setObject(rc.getRequest(), 
						 modelReference, localValue); 
		setValue(null);
            } catch ( FacesException e ) {
		// local value should be converted to String for rendering
                // purposes
                setValue(localValue.toString());
            }
	}
    }

    /**
    *   If we do not have a modelReference, do nothing.  If non-null
    *   value from model, overwrite local value, else do nothing. <P>
     * PENDING(aim): should be moved to ValueComponent subclass (?)
    * @return the value from the model
    */

    public Object pullValueFromModel(RenderContext rc) {
	Object result = null;
        if (null == modelReference) {
	    return result;
	}

	try {
            result = rc.getObjectAccessor().getObject(rc.getRequest(),
						      modelReference);
            if (null != result) {
                // convert the value to String for rendering purposes.
                setValue(result.toString());
	    }
	} catch ( FacesException e ) {
            // PENDING (visvan) skip this exception ??
	}
	return result;
    }

} // End of class UIComponent

