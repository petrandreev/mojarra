<html>
<head>
<title>JavaServer Faces 1.0 Standard Render Kit</title>
</head>
<body bgcolor="white">

<div align="center">
  <h1>JavaServer Faces 1.0 Standard Render Kit</h1>
  <h3>$Id: StandardRenderKit.html,v 1.13 2002/08/24 18:38:52 craigmcc Exp $</h3>
</div>


<div align="center">
  <h2>General Principles</h2>
</div>

<ul>
<li><strong>Tag Name Convention</strong> - The name of a tag is the standard
    HTML renderkit is derived from the name of the component class and the
    rendererType, according to the following algorithm:
    <ul>
    <li>Take the name of the component class (such as <code>UICommand</code>,
        strip off the <code>UIPrefix</code>, and convert to all lower case.
        </li>
    <li>If there is no renderer type specified, this is the complete name
        of the tag.</li>
    <li>If there is a renderer type specified, append an underscore character
        ("_") and the renderer type (converted to all lower case).</li>
    </ul></li>
<li><strong>Attribute "id"</strong> - All components are currently required to
    specify this value, which becomes the <code>componentId</code> of the
    underlying component.  Component ids must be unique within a parent.</li>
<li><strong>Attribute "fooClass"</strong> - Used to identify the CSS stylesheet
    class for rendering this component, which will itself be rendered as a
    <code>class</code> attribute.  We cannot use <code>class</code> as the
    attribute name of a JSP custom tag, so we adopt the convention that
    the "foo" is the same as the shortened name of the comopnent class
    (i.e. for all <code>UICommand</code> tags, the attribute name would be
    <code>commandClass</code>).  In cases where a component generates more than
    one HTML element, a surrounding HTML <code>&lt;span&gt;</code> element
    must be rendered in order to set the CSS style class.  For brevity, these
    render-dependent attributes are omitted from the table.</li>
<li><strong>Attribute "columnClasses"</strong> - Some renderers support an attribute
    of this name, which contains a comma-delimited list of CSS style classes
    that will be used in sequence.  If a rendered table has more columns than
    the number of class names in this list, it will be restarted from the
    beginning as many times as needed.  However, the first column in a new
    row will always be rendered with the first class listed here.</li>
<li><strong>Attribute "rowClasses"</strong> - Some renderers support an attribute
    of this name, which contains a comma-delimited list of CSS style classes
    that will be used in sequence.  If a rendered table has more rows than
    the number of class names in this list, it will be restarted from the
    beginning as many times as needed.</li>
<li><strong>Common HTML Attributes</strong> - Each tag that renders an HTML element
    should also support all of the low-level event handling (etc.) attributes
    of the corresponding HTML/4.0 element.  These render-dependent attributes
    are omitted from the table for brevity.</li>
</ul>


<div align="center">
  <h2>Component Class:  UICommand</h2>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>Button</td>
    <td>String</td>
    <td>commandName <em>or</em> modelReference</td>
    <td>type</td>
    <td>
      Submit FormEvent to application as per default behavior of UICommand.
    </td>
    <td>
      Render an HTML <code>&lt;button&gt;</code> element with the
      specified <code>type</code> (BUTTON, SUBMIT, RESET).  The
      <code>value</code> attribute is set to the command name.
      Nested child components (such as <code>UIGraphic</code> and
      <code>UIOutput</code>) can be used to provide the image and/or
      text that goes on the button.
    </td>
  </tr>

  <tr>
    <td>Hyperlink</td>
    <td>String</td>
    <td>commandName <em>or</em> modelReference</td>
    <td>&nbsp;</td>
    <td>
      Submit CommandEvent to application containing the command name
      of this command.
    </td>
    <td>
      Render an HTML <code>&lt;a&gt;</code> element that generates a
      link back to the tree identifier of the response page so that a
      command event can be enqueued.  Nested child components can be
      used to provide the image and/or text for the hyperlink.  URL
      rewriting will be performed to maintain session state in the
      absence of cookies.
    </td>
  </tr>

  <tr>
    <td>Hyperlink</td>
    <td>(none)</td>
    <td>&nbsp;</td>
    <td>href</td>
    <td>
      &nbsp;
    </td>
    <td>
      Render an HTML hyperlink to the specified URL.  Nested child components
      can be used to provide the image and/or text for the hyperlink.  URL
      rewriting will be performed to maintain session state in the absence
      of cookies.
    </td>
  </tr>

</table>


<div align="center">
  <h2>Component Class:  UIForm</h2>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>(none)</td>
    <td>(none)</td>
    <td>formName</td>
    <td>accept, accept-charset, enctype, method</td>
    <td>
      Per specified default decode behavior for <code>UIForm</code>.
    </td>
    <td>
      Per specified default encode behavior for <code>UIForm</code>.
    </td>
  </tr>

</table>



<div align="center">
  <h2>Component Class:  UIGraphic</h2>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>Image</td>
    <td>String</td>
    <td>url <em>or</em> modelReference</td>
    <td>&nbsp;</td>
    <td>
      &nbsp;
    </td>
    <td>
      Render an HTML <code>&lt;img&gt;</code> element with a <code>src</code>
      attribute set from the value of the current value of the
      underlying component.  URL rewriting will be performed to maintain
      session state in the absence of cookies.
    </td>
  </tr>

  <tr>
    <td>Image</td>
    <td>String</td>
    <td>&nbsp;</td>
    <td>key, bundle</td>
    <td>
      &nbsp;
    </td>
    <td>
      Render an HTML <code>&lt;img&gt;</code> element with a <code>src</code>
      attribute localized from a resource bundle.  URL rewriting will be
      performed to maintain session state in the absence of cookies.
    </td>
  </tr>

</table>



<div align="center">
  <h2>Component Class:  UIInput</h2>

  <p>Any child components nested inside this component will be rendered
  in an HTML <code>&lt;label&gt;</code> element associated with this
  component, aligned based on the <code>labelAlign</code> attribute
  (PAGE_START, PAGE_END, LINE_START, LINE_END).
  </p>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>Date</td>
    <td>Date, Long</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, dateStyle, timezone</td>
    <td>
      Get DateFormat instance as for encoding, parse text input,
      convert as necessary and store.
    </td>
    <td>
      Get current value, convert to Date, create localized DateFormat date
      instance for the specified dateStyle (SHORT, MEDIUM, LONG, FULL),
      set time zone (if specified), render formatted result as text input
      field.
    </td>
  </tr>

  <tr>
    <td>DateTime</td>
    <td>Date, Long</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, formatPattern, timezone</td>
    <td>
      Get DateFormat instance as for encoding, parse text input,
      convert as necessary and store.
    </td>
    <td>
      Get current value, convert to Date, create localized SimpleDateFormat
      based on formatPattern, set time zone (if specified), render formatted
      result as text input field.
    </td>
  </tr>

  <tr>
    <td>DateTime</td>
    <td>Date, Long</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, dateStyle, timeStyle, timezone</td>
    <td>
      Get DateFormat instance as for encoding, parse text input,
      convert as necessary, and store.
    </td>
    <td>
      Get current value, convert to Date, create localized DateFormat
      datetime instance for the specified dateStyle (SHORT, MEDIUM, LONG,
      FULL), and timeStyle (SHORT, MEDIUM, LONG, FULL), set time zone
      (if specified), render formatted result as text input field.
    </td>
  </tr>

  <tr>
    <td>Number</td>
    <td>numeric</td>
    <td>&nbsp;</td>
    <td>labelAlign, formatPattern</td>
    <td>
      Get DecimalFormat as for encoding, parse text input,
      convert as necessary, and store.
    </td>
    <td>
      Get current value, convert to numeric (as appropriate), create
      localized DecimalFormat based on formatPattern, render formatted result
      as text input field.
    </td>
  </tr>

  <tr>
    <td>Number</td>
    <td>numeric</td>
    <td>&nbsp;</td>
    <td>labelAlign, numberStyle</td>
    <td>
      Get NumberFormat instance as for encoding, parse text input,
      convert as necessary, and store.
    </td>
    <td>
      <p>Get current value, convert to numeric (as appropriate), create
      localized NumberFormat instance based on numberStyle (CURRENCY,
      INTEGER, NUMBER, PERCENT), render formatted result as
      text input field.</p>

      <p><strong>FIXME</strong> - When <code>numberStyle</code> is set to
      <code>CURRENCY</code>, we need to specify <code>currencyCode</code>
      and <code>currencySymbol</code> optional attributes, like the
      JSTL <code>&lt;fmt:formatNumber&gt;</code> tag allows.  It's probably
      worth having a separate <code>rendererType</code> for this.</p>
    </td>
  </tr>

  <tr>
    <td>Secret</td>
    <td>Any</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, redisplay</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value, convert to String, render literally as password
      input field.  The <code>redisplay</code> attribute is a boolean flag
      (default=false) indicating whether or not the actual value should be
      displayed -- it shows as stars on the screen but cleartext in the
      page source so some people will not want it.
    </td>
  </tr>

  <tr>
    <td>Text</td>
    <td>Any</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value, convert to String, render literally as text input
      field.
    </td>
  </tr>

  <tr>
    <td>Textarea</td>
    <td>Any</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value, convert to String, render literally as text input
      field.
    </td>
  </tr>

  <tr>
    <td>Time</td>
    <td>Date, Long</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, timeStyle, timezone</td>
    <td>
      Get DateFormat instance as for encoding, parse text input,
      convert as necessary and store.
    </td>
    <td>
      Get current value, convert to Date, create localized DateFormat time
      instance for the specified timeStyle (SHORT, MEDIUM, LONG, FULL), set
      time zone (if specified), render formatted result as text input field.
    </td>
  </tr>

  <tr>
    <td>Upload</td>
    <td>Any</td>
    <td>value <em>or</em> modelReference</td>
    <td>accept, filename, labelAlign</td>
    <td>
      Convert via JAF based on media type, and store.  <strong>FIXME:</strong>
      Availability of this Renderer implies that JSF implementations must
      support parsing of <code>multipart/form-data</code> uploads.
    </td>
    <td>
      Render an HTML <code>&lt;input type="file"&gt;</code> control, using the
      <code>filename</code> attribute (if present) to set the default
      filename value.
    </td>
  </tr>

</table>



<div align="center">
  <h2>Component Class:  UIOutput</h2>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>Date</td>
    <td>Date, Long</td>
    <td>value <em>or</em> modelReference</td>
    <td>dateStyle, timezone</td>
    <td>
      &nbsp;
    </td>
    <td>
      Get current value, convert to Date, create localized DateFormat date
      instance for the specified dateStyle (SHORT, MEDIUM, LONG, FULL),
      set time zone (if specified), render formatted result.
    </td>
  </tr>

  <tr>
    <td>DateTime</td>
    <td>Date, Long</td>
    <td>value <em>or</em> modelReference</td>
    <td>formatPattern, timezone</td>
    <td>
      &nbsp;
    </td>
    <td>
      Get current value, convert to Date, create localized SimpleDateFormat
      based on formatPattern, set time zone (if specified), render formatted
      result.
    </td>
  </tr>

  <tr>
    <td>DateTime</td>
    <td>Date, Long</td>
    <td>value <em>or</em> modelReference</td>
    <td>dateStyle, timeStyle, timezone</td>
    <td>
      &nbsp;
    </td>
    <td>
      Get current value, convert to Date, create localized DateFormat
      datetime instance for the specified dateStyle (SHORT, MEDIUM, LONG,
      FULL), and timeStyle (SHORT, MEDIUM, LONG, FULL), set time zone
      (if specified), render formatted result as text input field.
    </td>
  </tr>

  <tr>
    <td>Errors</td>
    <td>(none)</td>
    <td>(none)</td>
    <td>compoundId</td>
    <td>
      &nbsp;
    </td>
    <td>
      Render the set of error messages (if any) that are associated with the
      specified compound identifier, or the global errors not associated with
      any component if the compoundId is a zero-length String.  If no
      compoundId at all is specified, render all error messages.
    </td>
  </tr>

  <tr>
    <td>Label</td>
    <td>(none)</td>
    <td>(none)</td>
    <td>for</td>
    <td>
      &nbsp;
    </td>
    <td>
      Render the nested components surrounded by an HTML
      <code>&lt;label&gt;</code> element with the specified <code>for</code>
      attribute (which must match the rendered <code>id</code> attribute
      for some input field).
    </td>
  </tr>

  <tr>
    <td>Message</td>
    <td>Any</td>
    <td>value <em>or</em> modelReference</td>
    <td>&nbsp;</td>
    <td>
      &nbsp;
    </td>
    <td>
      <p>Get current value, convert to String, treat as MessageFormat pattern
      (nested UIParameter components for parameter substitution), render
      formatted result.</p>

      <p><strong>FIXME</strong> - Consider specifying optimizations for reuse
      of MessageFormat instances, bypassing them in some cases (i.e. no
      "{" character in string and/or no arguments provided).</p>
    </td>
  </tr>

  <tr>
    <td>Message</td>
    <td>Any</td>
    <td>&nbsp;</td>
    <td>key, bundle</td>
    <td>
      &nbsp;
    </td>
    <td>
      <p>Get localized resource from resource bundle, convert to String, treat
      as a MessageFormat pattern (nested UIParameter components for
      parameter substitution), render formatted result.</p>

      <p><strong>FIXME</strong> - Consider specifying optimizations for reuse
      of MessageFormat instances, bypassing them in some cases (i.e. no
      "{" character in string and/or no arguments provided).</p>
    </td>
  </tr>

  <tr>
    <td>Number</td>
    <td>numeric</td>
    <td>&nbsp;</td>
    <td>formatPattern</td>
    <td>
      &nbsp;
    </td>
    <td>
      Get current value, convert to numeric (as appropriate), create
      localized DecimalFormat based on formatPattern, render formatted result.
    </td>
  </tr>

  <tr>
    <td>Number</td>
    <td>numeric</td>
    <td>&nbsp;</td>
    <td>numberStyle</td>
    <td>
      &nbsp;
    </td>
    <td>
      <p>Get current value, convert to numeric (as appropriate), create
      localized NumberFormat instance based on numberStyle (CURRENCY,
      INTEGER, NUMBER, PERCENT), render formatted result.</p>

      <p><strong>FIXME</strong> - When <code>numberStyle</code> is set to
      <code>CURRENCY</code>, we need to specify <code>currencyCode</code>
      and <code>currencySymbol</code> optional attributes, like the
      JSTL <code>&lt;fmt:formatNumber&gt;</code> tag allows.  It's probably
      worth having a separate <code>rendererType</code> for this.</p>
    </td>
  </tr>

  <tr>
    <td>Text</td>
    <td>Any</td>
    <td>value <em>or</em> modelReference</td>
    <td>&nbsp;</td>
    <td>
      &nbsp;
    </td>
    <td>
      Get current value, convert to String, render literally.
    </td>
  </tr>

  <tr>
    <td>Time</td>
    <td>Date, Long</td>
    <td>value <em>or</em> modelReference</td>
    <td>numberStyle, timezone</td>
    <td>
      &nbsp;
    </td>
    <td>
      Get current value, convert to Date, create localized DateFormat time
      instance for the specified numberStyle (SHORT, MEDIUM, LONG, FULL), set
      time zone (if specified), render formatted result.
    </td>
  </tr>

</table>


<div align="center">
  <h2>Component Class:  UIPanel</h2>

  <p>Note that CSS style classes cascade, so that panel renderers that use an
  HTML table can establish a hierarchy of styles by using the
  <code>panelClass</code>, <code>rowClasses</code>, and
  <code>columnClasses</code> attributes in many flexible patterns.</p>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>Data</td>
    <td>(none)</td>
    <td>modelReference</td>
    <td>var</td>
    <td>
      &nbsp;
    </td>
    <td>
      Represents the template of a row to be generated for each element
      of the <code>List</code> pointed at by <code>modelReference</code>.
      Each element of the collection will be exposed as a request attribute
      named by <code>var</code>, so that model reference expressions in the
      template components can access the values for the current element.
      There should be one child component per column to be created.
    </td>
  </tr>

  <tr>
    <td>Grid</td>
    <td>(none)</td>
    <td>&nbsp;</td>
    <td>columnClasses, columns, footerClass, headerClass,
        rowClasses</td>
    <td>
      &nbsp;
    </td>
    <td>
      Render an HTML table (from our child components)
      based on the following rules:
      <ul>
      <li>If <code>headerClass</code> is specified, the first child will be
          rendered as a row across all of the columns.</li>
      <li>Each intervening child is rendered in a separate table data
          element, with a new row started each <code>columns</code>
          children.</li>
      <li>If <code>footerClass</code> is specified, the last child will be
          rendered as a row across all of the columns.</li>
      </ul>
    </td>
  </tr>


  <tr>
    <td>Group</td>
    <td>(none)</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>
      &nbsp;
    </td>
    <td>
      Render the child components.  This component exists simply to
      allow the creation of arbitrary groups of components where a
      parent component expects to see a single child (such as the
      contents of an individual cell for the <em>Grid</em> renderer).
    </td>
  </tr>


  <tr>
    <td>List</td>
    <td>(none)</td>
    <td>&nbsp;</td>
    <td>columnClasses, footerClass, headerClass, rowClasses</td>
    <td>
      &nbsp;
    </td>
    <td>
      Render an HTML table (from our child components)
      based on the following rules:
      <ul>
      <li>If <code>headerClass</code> is specified, the first child should be
          a <code>panel_group</code> whose children represent column headers
          for the table to be rendered.</li>
      <li>Zero or more <code>panel_data</code> tags that identify the data
          collection to be iterated over, and whose children represent a
          template for each row to be rendered.</li>
      <li>If <code>footerClass</code> is specified, the last child should be
          a <code>panel_group</code> whose children represent column footers
          for the table to be rendered.</li>
      </ul>
    </td>
  </tr>

</table>


<div align="center">
  <h2>Component Class:  UIParameter</h2>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>(None)</td>
    <td>Any</td>
    <td>name, value <em>or</em> modelReference</td>
    <td>&nbsp;</td>
    <td>
      &nbsp;
    </td>
    <td>
      &nbsp;
    </td>
  </tr>

</table>


<div align="center">
  <h2>Component Class:  UISelectBoolean</h2>

  <p>Any child components nested inside this component will be rendered
  in an HTML <code>&lt;label&gt;</code> element associated with this
  component, aligned based on the <code>labelAlign</code> attribute
  (PAGE_START, PAGE_END, LINE_START, LINE_END).
  </p>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>Checkbox</td>
    <td>Convertible to boolean</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value, render as an HTML
      <code>&lt;input type="checkbox"&gt;</code> element.
    </td>
  </tr>

</table>



<div align="center">
  <h2>Component Class:  UISelectMany</h2>

  <p>Any child components (except UISelectItem and UISelectOne instances)
  nested inside this component will be rendered
  in an HTML <code>&lt;label&gt;</code> element associated with this
  component, aligned based on the <code>labelAlign</code> attribute
  (PAGE_START, PAGE_END, LINE_START, LINE_END).
  </p>

  <p><strong>FIXME</strong> - Consider supporting collation of the collected
  options.</p>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>Checkbox</td>
    <td>Convertible to String</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, layout</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value, get available items from nested child
      <code>UISelectItem</code> and <code>UISelectItems</code>
      components, render as a series of checkboxes laid out
      according to the <code>layout</code> attribute (PAGE_DIRECTION,
      LINE_DIRECTION).
    </td>
  </tr>

  <tr>
    <td>Listbox</td>
    <td>Convertible to String[]</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value(s), get available items from nested child
      <code>UISelectItem</code> and <code>UISelectItems</code>
      components, render as an HTML <code>&lt;select&gt;</code>
      element that displays all of the possible choices (and
      therefore needs no scrollbar).
    </td>
  </tr>

  <tr>
    <td>Menu</td>
    <td>Convertible to String[]</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, size</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value(s), get available items from nested child
      <code>UISelectItem</code> and <code>UISelectItems</code>
      components, render as an HTML <code>&lt;select&gt;</code>
      element that displays the number of elements specified by
      the <code>size</code> attribute (default=1) at a time.
    </td>
  </tr>

</table>



<div align="center">
  <h2>Component Class:  UISelectOne</h2>

  <p>Any child components (except UISelectItem and UISelectOne instances)
  nested inside this component will be rendered
  in an HTML <code>&lt;label&gt;</code> element associated with this
  component, aligned based on the <code>labelAlign</code> attribute
  (PAGE_START, PAGE_END, LINE_START, LINE_END).
  </p>

  <p><strong>FIXME</strong> - Consider supporting collation of the collected
  options.</p>
</div>

<table width="100%" border="1" cellpadding="3" cellspacing="3"

  <tr>
    <th align="center">Renderer Type</th>
    <th align="center">Data Type</th>
    <th align="center">Component Attributes</th>
    <th align="center">Renderer Attributes</th>
    <th align="center" width="25%">Decode Behavior</th>
    <th align="center" width="35%">Encode Behavior</th>
  </tr>

  <tr>
    <td>Listbox</td>
    <td>Convertible to String</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value, get available items from nested child
      <code>UISelectItem</code> and <code>UISelectItems</code>
      components, render as an HTML <code>&lt;select&gt;</code>
      element that displays all of the possible choices (and
      therefore needs no scrollbar).
    </td>
  </tr>

  <tr>
    <td>Menu</td>
    <td>Convertible to String</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, size</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value, get available items from nested child
      <code>UISelectItem</code> and <code>UISelectItems</code>
      components, render as an HTML <code>&lt;select&gt;</code>
      element that displays the number of elements specified by
      the <code>size</code> attribute (default=1) at a time.
    </td>
  </tr>

  <tr>
    <td>Radio</td>
    <td>Convertible to String</td>
    <td>value <em>or</em> modelReference</td>
    <td>labelAlign, layout</td>
    <td>
      Convert as necessary and store.
    </td>
    <td>
      Get current value, get available items from nested child
      <code>UISelectItem</code> and <code>UISelectItems</code>
      components, render as a series of radio buttons laid out
      according to the <code>layout</code> attribute (PAGE_DIRECTION,
      LINE_DIRECTION).
    </td>
  </tr>

</table>




</body>
</html>
