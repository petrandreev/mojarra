<?xml version="1.0"?>

<!-- Informal DTD for contents of "issue" subelements:

  id                Unique issue identifier
  originator        EG member (or public comment) that originated the issue
  summary           Summary one-line description
  description       Full (multiline) description of the issue
  resolution        Full (multiline) description of resolution
  status            OPEN, CLOSED, LATER
  date              Date on which status was last changed

-->

<issues>


<issue>
  <id>ObjectManager-1</id>
  <originator>Craig</originator>
  <summary>Re-introduce Object Manager Functionality</summary>
  <description>
    <p>Currently, it is inconvenient to use request scope beans in
    model reference expressions, because the corresponding object
    is not created automatically.  This was one of the features provided
    in the <em>Object Manager</em> functionality that was present in
    version .03 of the JSF Spec, but has been absent since.</p>

    <p>Per Jeff's comments - might want to pass the component instance,
    instead of the value, to the <code>setModelValue()</code> method to
    enable a "model handler".  Jeff - can you expand on this?</p>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Craig to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Large</effort>
</issue>


<issue>
  <id>OutputMethods-2</id>
  <originator>Craig</originator>
  <summary>Consider refactoring OutputMethod from ResponseWriter</summary>
  <description>
    <p>Currently, the extended methods for writing elements and attributes
    (proposed by Adam) are defined on <code>ResponseWriter</code> directly.
    The current implementation of <code>javax.faces.webapp.FacesTag</code>
    requires a concrete implementation of <code>JspResponseWriter()</code>
    to be in the API classes, which is undesireable for something as
    detailed as these methods.  Options to consider:</p>
    <ul>
    <li>Modify <code>FacesTag</code> so that it can look up an
        implementation of <code>JspResponseWriter</code> somehow.</li>
    <li>Extract the element and attribute methods into a wrapper API
        around a ResponseWriter (analogous to the way that
        <code>java.io.FilterWriter</code> can wrap a Writer.  (Still
        need a generic discovery mechanism though).</li>
    </ul>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Craig to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>Listeners-3</id>
  <originator>Craig</originator>
  <summary>Review Event Listener Architecture</summary>
  <description>
    <p>Need to review how the event listener mechanism is currently
    architected in light of real world component development.  In
    particular:</p>
    <ul>
    <li>Registering listeners on a receiving component (versus globally).</li>
    <li>Directing events to a particular component (versus a global
        "this thing happened" approach).</li>
    </ul>

    <p>Additional note from Hans (09/13):  Should we really define the
    add/clear/get/removeRequestEventHandler methods on UIComponent?  It seems
    like we want strongly typed events (as we say we do in the overview),
    more specific component types should instead declare a set of methods
    for things like "ValueUpdatedEventHandler" (or Listener) to advertise
    that they generate (<em>Spec Lead edit - or consume</em>) a particular
    event type (along the lines defined by the JavaBeans spec).</p>

    <p>Additional notes from Joe (09/11):</p>
    <ul>
    <li>Should we subclass FacesEvent as RequestEvent and ApplicationEvent
        for type safety at the appropriate event listeners?</li>
    <li>Do we need to define an order of event delivery (such as form events
        before command events at the application level?</li>
    </ul>

    <p>See Also:  [StandardComponentEvents-38], [EventProcessingPhases-39].</p>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Craig to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>NamedChild-4</id>
  <originator>Adam</originator>
  <summary>Reintroduce "Named Child" Concept for UIComponents</summary>
  <description>
    <p>Introduce a concept similar to what JSP 2.0 has introduced with
    <code>&lt;jsp:attribute&gt;</code> and the JspFragment class, in
    order to facilitate building complex UI components.</p>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Adam to present writeup to EG.</p>
    <p><em>11 Sep 2002</em> - Adam submitted a proposal on this.</p>
    <p><em>24 Oct 2002</em> - Craig submitted analysis and recommendation
       to the EG mailing list.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Medium</effort>
</issue>


<issue>
  <id>StateSaving-5</id>
  <originator>Adam</originator>
  <summary>Re-evaluate Question of State Saving Volume/Location</summary>
  <description>
    <p>We currently put the onus for this on the JSP <code>use_faces</code>
    tag, which is not sufficiently generalized to support non-JSP uses.</p>

    <p>Additional related thoughts from Hans (09/13):</p>
    <ul>
    <li>Should state information saved in the session be thrown away if a
        different tree is requested, or saved in case the original tree might
        get re-requested?</li>
    <li>Should we add some sort of event that can notify the application
        about state saving and state restoring activities?</li>
    </ul>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Adam to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Medium</effort>
</issue>


<issue>
  <id>ServletDependencies-6</id>
  <originator>Adam</originator>
  <summary>Servlet API Dependencies</summary>
  <description>
    <p>To what extent do we wish to abstract away the current dependencies
    on the servlet API?  This may be necessary for the Portlet JSR, and
    it would be necessary for using JSF to create content outside of
    servlets.</p>

    <p>Example scenario from Hans (09/13):  Having a command event include
    a Map of parameter names/values directly, instead of letting the event
    handler pull them out of the servlet request.  (<em>Craig - to be
    complete, we'd want to think about maps of headers and cookies also</em>).
    </p>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Adam to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>JspDependencies-7</id>
  <originator>Hans</originator>
  <summary>JSP API Dependencies</summary>
  <description>
    <p>Although there are many who suggest we base JSF on JSP 1.2 for
    immediate acceptance reasons, it forces us to do any custm tag
    implementation classes based on the JSP 1.2 Tag and BodyTag APIs.
    Can we avoid creating a dependency like this that ties us to this
    API (which could potentially be deprecated in some future JSP spec)?</p>
  </description>
  <resolution>
    <p><em>02 Oct 2002</em> - Consensus appears to be that we stick with
       the original decision to support JSP 1.2.</p>
  </resolution>
  <status>CLOSED</status>
  <status-date>02 Oct 2002</status-date>
  <priority>5</priority>
  <effort></effort>
</issue>


<issue>
  <id>ELDependencies-8</id>
  <originator>Hans</originator>
  <summary>JSP EL API Dependencies</summary>
  <description>
    <p>Basing JSF on JSP 1.2 means we must specify our version of the EL
    language being used for model references in the JSF specification (or
    perhaps point at the non-normative one in JSTL 1.0), since we would
    not want to tie ourselves to the JSP 2.0 formal definition of the
    language.  Is this acceptable?  Can we deal with it in a different
    way?</p>

    <p>In addition, we currently need a feature that is not supported by
    the JSTL 1.0 or JSP 2.0 versions of the EL -- model object
    <em>setting</em> as well as getting.  We're going to need to address
    the syntax and semantics of this no matter what JSP version we choose
    to depend on.</p>

    <p>Futher, we have the opportunity to simplify the APIs somewhat by
    using EL expressions for some common lookup scenarios such as resource
    bundles (see Adam's mail threads for more  on this).</p>
  </description>
 <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Large</effort>
</issue>


<issue>
  <id>TreeCreation-9</id>
  <originator>Jeff</originator>
  <summary>Component Tree Creation in Render Response</summary>
  <description>
    <p>Our current design uses a pass through <em>Render Response</em> to
    initially create the component tree in most cases, which makes for
    interesting design decisions on some complex rendering scenarios.  It
    would be useful to re-investigate creating the component tree from a
    static analysis of the JSP page source.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>ComponentNamespace-10</id>
  <originator>Jeff</originator>
  <summary>Component Identifier Namespace</summary>
  <description>
    <p>We currently use a hierarchical namespace for components, both
    in the tree itself and in the rendered page.  Among other things,
    this causes a problem with rendering <code>id</code> attributes on
    the output HTML elements, because '/' is not a valid IDREF character.
    Should we go to a flat namespace for components (at least in the
    rendered output, and perhaps in addition to hierarchical names)?</p>

    <p>We will also need a way for components to predict what the rendered
    <code>id</code> attribute for a component was (if it has been rendered)
    or will be (if it has not been rendered yet) in order to generate
    corresponding JavaScript.</p>
  </description>
  <resolution>
    <p><em>02 Oct 2002</em> - Consolidate [ComponentIdentifiers-27]
       into this item.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>ApplicationHandler-11</id>
  <originator>Public</originator>
  <summary>Rethink ApplicationHandler</summary>
  <description>
    <p>Please rethink this ApplicationHandler business.  Application
    handlers are going to wind up having a processEvent method that's
    a huge switch statement that switches off the event type and forces
    casting, thereby committing three Cardinal OO sins.  Another huge
    drawback to this design is that the application handler accesses
    tree ids directly, which will increase the maintenance burden if you
    happen to change the name of a JSP page that the application handler
    forwards to.</p>

    <p>Additional notes from Hans (09/13):</p>
    <ul>
    <li>Is the "stop immediately" approach (returning Phase.GOTO_RENDER)
        sufficient?  What if we really do want to ensure that all the
        queued application events are handled?</li>
    <li>Is there any guaranteed ordering of application event processing
        that clever apps can use to get around the current restrictions?</li>
    <li>We also need to incorporate some level of navigation support.  The
        application will probably deal with this as the return value from
        the application event handler, so incorporate it in this issue.</li>
    </ul>

    <p>Additional notes from Joe (09/11):</p>
    <ul>
    <li>Part of the "navigation handler" functionality should be using the
        return value from the application event handler to select the new
        response tree id, instead of the app calling setResponseTree()
        directly (although there might be cases where the app still wants
        to do that, these should be the exception).</li>
    <li>See Joe's additional design remarks on this in his comments on
        Section 6.3 in the message entitled "comments on 0902 specification
        draft" dated 09/11/2002.</li>
    </ul>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>ModelReferences-12</id>
  <originator>Public</originator>
  <summary>Are modelReference attributes required?</summary>
  <description>
    <p>Must I really specify a modelReference attribute for every component?
    That really increases the verbosity of my JSP pages -- for those like me
    that suffer from RSI its a real pain.  It certainly also painful for those
    that don't suffer from RSI.</p>

    <p>Can't the association be done with reflection?  Can't the form beans
    be specified in a configuration file?  Please?</p>
  </description>
  <resolution>
    <p><em>02 Oct 2002</em> - Consistency with the EL syntax in JSTL 1.0
       and JSP 2.0 mandates complete expressions, and avoids artificial
       restrictions that a Struts-like style (single form bean) would
       impose.</p>
  </resolution>
  <status>CLOSED</status>
  <status-date>02 Oct 2002</status-date>
  <priority>5</priority>
  <effort></effort>
</issue>


<issue>
  <id>XmlModel-13</id>
  <originator>Public</originator>
  <summary>Please include support for an XML Model</summary>
  <description>
    <p>Great work on this JSR.  I think it will debunk the claim that
    Visual Studio .NET is "easier to use" than J2EE development products.</p>

    <p>What you are missing here is support for an XML model rather than
    JavaBeans.  JSTL has excellent support for rendering an XML model and
    I am surprised to find this lacking in JSR-127.</p>
  </description>
  <resolution>
    <p><em>02 Oct 2002</em> - Suitable for deferral to JSF 1.1.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>4</priority>
  <effort></effort>
</issue>


<issue>
  <id>CommandHyperlink-14</id>
  <originator>RI Team</originator>
  <summary>Cannot implement command_hyperlink as specified</summary>
  <description>
    <p>The decode behavior of the <code>Hyperlink</code> Renderer is
    currently specified as "send a CommandEvent to the application."
    However, the current definition of phase switching does not provide
    a path from <em>Process Request Events</em> to <em>Invoke
    Application</em> without going through validations and model updates.
    These phases are inappropriate in a CommandEvent scenario, because
    a form (and the corresponding input fields) did not get submitted.</p>

    <p>Jeff:  In the past I've done this via JavaScript and Form.submit()
    for pages that contain other form data and with standard links with
    parameters for pages that are display only.</p>

    <p>Jeff:  Why is the second Hyperlink renderer a UICommand component,
    when it doesn't trigger a command event?  Why isn't it under UIOutput
    instead?</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>UserAgent-15</id>
  <originator>Craig</originator>
  <summary>Do we need a UserAgent classification scheme?</summary>
  <description>
    <p>So far during the development of the Standard HTML RenderKit,
    it has not been necessary to emit any browser-specific code.  Such
    a need might come in the future, and will certainly be necessary
    for user-created components that create complex DHTML and/or JavaScript
    code that depends on the DOM of the browser being targeted.</p>

    <p>Making applications parse the <code>User-Agent</code> header seems
    like something we might want to abstract away.  Because not all
    RenderKits will target web browsers, it's not just a matter of
    identifying what browser type is in use.  Perhaps a UserAgentClassifier
    plug-in interface that is part of the RenderKit?</p>

    <p>If we ever do start emitting browser-dependent code from the
    standard RenderKit, it's also important to understand how caches
    can negatively affect application behavior by caching the content
    for one browser and serving it to another.  This only happens if the
    request URL is identical, which is something to avoid.</p>

    <p>NOTE:  JSR188 <a href="http://jcp.org/jsr/detail/188.jsp">
    http://jcp.org/jsr/detail/188.jsp</a> is operating in this space.
    We should take its development into account.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>DataGrid-16</id>
  <originator>Jeff</originator>
  <summary>What should a DataGrid control look like?</summary>
  <description>
    <p>Many existing GUI frameworks for web applications have data grid
    controls that allow page authors to do relatively sophisticated hookups
    to back end data sources.  It is very likely that Faces will need
    such a control as well.  What should it look like, in terms of the
    Faces component and renderer design?</p>

    <p>Besides supporting JavaBean arrays, Collections, and Maps (like the
    propotype "List" renderer in jsf-psuedo) does, we should consider
    supporting a control whose model reference points at either a JSTL
    <code>javax.servlet.jsp.jstl.sql.Result</code> or a JDBC
    <code>java.sql.ResultSet</code> (or <code>RowSet</code>) directly.
    Using a <code>Result</code> object would allow very easy interoperability
    with JSTL's SQL tags.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>05 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Large</effort>
</issue>


<issue>
  <id>NonJSPRendering-17</id>
  <originator>Hans</originator>
  <summary>Non-JSP Rendering Environment</summary>
  <description>
    <p>We have spent a significant amount of effort on making sure that Faces
    interacts well with JSP and related technologies (such as JSTL).  We need
    to prove (at a minimum to ourselves) that the basic APIs support rendering
    in a non-JSP environment as well.  How much of this should show up in
    the RI?  Or in ancillary distributions (along with enhanced renderkits)?
    </p>

    <p>Added Notes from Hans:  I reported that in my proof of concept
    implementation with a DOM-based rendering model, I needed to implement
    a custom ViewHandler, a RenderKit (with Renderers, of course), and a
    TreeFactory.  It seems to me that the need for a custom TreeFactory
    indicates a flaw in our abstractions, since it should be enough with a
    ViewHandler and a RenderKit.</p>

    <p>Added Notes from Hans:  Ana added that she feels that none of these
    custom classes should be needed, arguing (I assume) that JSF should
    provide all that's needed for DOM-based rendering in addition to JSP-based
    rendering.  I'm not sure yet if I agree or not, so let's see how it plays
    out when we look at the impact.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>05 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>TreeClass-18</id>
  <originator>EG</originator>
  <summary>Tree/TreeFactory Classes Needed?</summary>
  <description>
    <p>One of the original motivations for the <code>Tree</code> and
    <code>TreeFactory</code> classes was the notion of constructing an
    entire component tree from some external metadata.  Our current approach
    that allows the tree to be constructed dynamically during Render Response
    makes the need for this substantially weaker.</p>

    <p>Can we get rid of TreeFactory entirely?  Probably.</p>

    <p>Can we get rid of Tree as well?  Possibly -- at the cost of replacing
    two FacesContext properties (<code>requestTree</code> and
    <code>responseTree</code>) with six (<code>renderKitId</code>,
    <code>root</code>, and <code>treeId</code> for each of the two trees).</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>05 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Small</effort>
</issue>

<issue>
  <id>EventTypes-19</id>
  <originator>EG</originator>
  <summary>Both FormEvent and CommandEvent?</summary>
  <description>
    <p>The current APIs have both CommandEvent (passes the command name)
    and FormEvent (subclasses CommandEvent and adds the form name).  Do we
    need both?  It would seem that command event is required in any case
    (so that an application can distinguish which submit button was used).
    Does FormEvent add enough value to make it worth keeping?</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>UIParameter-20</id>
  <originator>EG</originator>
  <summary>Should UIParameter be a component?</summary>
  <description>
    <p>Should UIParameter be a component?  If it's not, how would we do
    things like specify the substitution parameters for the
    <code>Message</code> renderer type?</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>UIComponentBase-21</id>
  <originator>EG</originator>
  <summary>UIComponentBase exists in API but not Spec</summary>
  <description>
    <p>Based on EG feedback, UIComponent was converted from an abstract class
    to an interface, and UIComponentBase added as an abstract class.  This
    change has not yet been reflected in the spec.  Do we want to keep it?
    If so, the spec needs to be updated to reflect this.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>OASIS-22</id>
  <originator>Kris &amp; Bart</originator>
  <summary>Relationship with WSIA/WSRP Work</summary>
  <description>
    <p>Review current progress on the OASIS <em>Web Services for Interactive
    Applications</em> and <em>Web Services for Remote Portals</em>, and
    make any needed recommendations for changes in JSF.</p>

    <p><a href="http://www.oasis-open.org/">http://www.oasis-open.org</a></p>

    <p>NOTE:  WSRP seems to me (Craig) to be clearly in the JSR168 sphere.</p>

    <p>Craig:  The idea of supporting components that implement a web service
    seems like a good JSF 1.1 topic, although it may turn out that a generic
    component (as opposed to service-specific) is not feasible.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>PortletTerminology-23</id>
  <originator>Kris &amp; Bart</originator>
  <summary>Alignment with JSR168 Terminology Definitions</summary>
  <description>
    <p>We should ensure that there is alignment between terminology definitions
    in JSR168 (Portlets) and JSR127 (Faces) where the concepts are the same.
    </p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>FacesServlet-24</id>
  <originator>Kris &amp; Bart</originator>
  <summary>Should we use FacesServlet or FacesFilter</summary>
  <description>
    <p>Re-examine our current choice of using a Servlet instead of a Filter
    for the Faces mini-front-controller.  Among the issues:</p>
    <ul>
    <li>JSR168 choice to mimic servlet APIs instead of extend them.</li>
    <li>Filters don't work on RequestDispatcher.include() calls on Servlet
        2.3 (but this is possible in Servlet 2.4).</li>
    </ul>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>LookAndFeel-25</id>
  <originator>Kris &amp; Bart</originator>
  <summary>How will JSF address look and feel</summary>
  <description>
    <p>This is a somewhat open ended question.  The philosophy in the 0902
    version of the standard renderers is to delegate as much of possible to
    CSS stylesheets and give page authors the ability to configure the
    stylesheet class (or classes) to use for rendering each component.
    That seems to be the direction that W3C encourages for HTML.  Is that
    the way we want to stay?</p>

    <p>NOTE:  Running the jsf-pseudo examples under Netscape 4.x looked
    surprisingly better than I thought it would, but there are going to be
    obvious issues around stylesheet directives that 4.x doesn't support
    or implements incorrectly.</p>

    <p>Craig:  I think supporting overall page look-and-feel, and things
    like skinning, are suitable for JSF 1.1.  The current use of CSS is
    more focused on the rendering of individual components than on overall
    layout.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
  <priority>4</priority>
  <effort></effort>
</issue>


<issue>
  <id>ConfigFiles-26</id>
  <originator>Kris &amp; Bart</originator>
  <summary>Specify standard app configuration file format(s)</summary>
  <description>
    <p>There are several cases where we expect page authors, component
    writers, and application develop to register custom classes with a
    JSF implementation, typically at startup time (application handler,
    UIComponents, converters, renderers, and so on).  We should probably
    define a standard configuration file format (probably in XML) so that
    applications do not need to include programmatic logic to perform the
    necessary registrations.  Section 9.3 of the spec is already reserved
    for documenting such formats.</p>

    <p>NOTE:  We'll probably want to specify a standard servlet init parameter
    that specifies the resource path to such config files.  For maximum
    flexibility, more than one config file should be allowed.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>09 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Large</effort>
</issue>


<issue>
  <id>ComponentIdentifiers-27</id>
  <originator>Joe</originator>
  <summary>Define a mechanism for knowing rendered component ids</summary>
  <description>
    <p>There are several scenarios in which it is important for the logic
    performing component rendering to be able to predict what the rendered
    "id" for another component will be, whether or not that component has
    actually been rendered yet.  Sample use cases:</p>
    <ul>
    <li>Generating client-side JavaScript that references more than
        one component.</li>
    <li>Generating client-side JavaScript for validation.</li>
    <li>Master-detail UI, so that you can generate hyperlinks for the
        items that cross reference between the master and the items.</li>
    </ul>
  </description>
  <resolution>
    <p><em>11 Sep 2002</em> - Joe submitted a proposal message titled
    "form handling design pattern for viewing/editing entities".</p>
    <p><em>02 Oct 2002</em> - Consolidate this item with
       [ComponentNamespace-10].</p>
  </resolution>
  <status>CLOSED</status>
  <status-date>02 Oct 2002</status-date>
  <priority>5</priority>
  <effort></effort>
</issue>


<issue>
  <id>VisibleProperty-28</id>
  <originator>Jeff</originator>
  <summary>Define a "visible" property on UIComponent</summary>
  <description>
    <p>It's legal for a component to be removed from the response tree at
    many stages of the request processing lifecycle.  However, in the current
    JSP scenario, the component will get recreated again when its tag is
    executed.  Other frameworks deal with this by adding a "visible" property
    on the component, where a <code>false</code> setting disables rendering.
    </p>
  </description>
  <resolution>
    <p><em>11 Sep 2002</em> - Jeff submitted an analysis and proposal message
    titled "Adding a 'visible' property to UIComponent".</p>
  </resolution>
  <status>OPEN</status>
  <status-date>11 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>Converters-29</id>
  <originator>EG</originator>
  <summary>Add by-Class registration and lookup of Converters</summary>
  <description>
    <p>Per EG discussion, we added <code>javax.faces.convert.Converter</code>
    APIs in 20020902.  Based on subsequent discussion, we also need to add
    by-Class registrtation and lookup of Converters, including search order
    definition on the by-Class lookup (based on closest inheritance).</p>

    <p>Additional note from Joe - should be able to use these converters
    for UISelectOne/UISelectMany data too (Object/Object[] instead of
    String/String[]).</p>
  </description>
  <resolution>
    <p><em>11 Sep 2002</em> - Craig to add these APIs and spec changes.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>11 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Medium</effort>
</issue>


<issue>
  <id>OnLoad-30</id>
  <originator>Hans</originator>
  <summary>How to add "onLoad" JavaScript handlers to a response</summary>
  <description>
    <p>This is an issue I have hinted at in my arguments for a
    DOM based rendering model, and I also saw it mentioned as an issue
    in the public discussion about the released draft.</p>

    <p>Craig:  There is probably some overlap with [StateSaving-5], at least
    for the timing issues.</p>
  </description>
  <resolution>
    <p><em>02 Oct 2002</em> - Consolidate [JavaScript-31] into this item.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>JavaScript-31</id>
  <originator>Hans</originator>
  <summary>How to add JavaScript event handlers to a response</summary>
  <description>
    <p>It's been mentioned a number of times that we want to do so,
    but it's not in the spec yet.</p>

    <p>Craig:  Some overlap with [ComponentIdentifiers-27], which is a
    key enabler.</p>
  </description>
  <resolution>
    <p><em>02 Oct 2002</em> - Consolidated into [OnLoad-30].</p>
  </resolution>
  <status>CLOSED</status>
  <status-date>02 Oct 2002</status-date>
  <priority>5</priority>
  <effort></effort>
</issue>


<issue>
  <id>InitialTree-32</id>
  <originator>Hans</originator>
  <summary>How to wire up initial tree in a rendering-neutral way</summary>
  <description>
    <p>This question pops up from time to time.  I, for instance,
    suggested a while back that we need to define another lifecycle that
    deals with this case.  The 0902 draft only says that an empty tree is
    created, but it needs to be populated as well, and there's still no
    arrow from the Reconstitute Request Tree phase to the Render
    Response phase.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>HandlersModifyTree-33</id>
  <originator>Hans</originator>
  <summary>Should request event handlers be allowed to modify the
           component tree</summary>
  <description>
    <p>I have argued that this will cause confusion, and that
    event handlers and other code should instead just set component
    properties and leave it up to the component to respond to this by
    adding/removing child components, remove itself (or make itself
    invisible/not rendered as Jeff and Adam suggest), and that only the
    application should be allowed to switch to a new response tree.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>HandlersSelectTree-34</id>
  <originator>Hans</originator>
  <summary>Should request event handlers be allowed to select a new
           response tree identifier?</summary>
  <description>
    <p>I have argued that this will cause confusion, and that
    event handlers and other code should instead just set component
    properties and leave it up to the component to respond to this by
    adding/removing child components, remove itself (or make itself
    invisible/not rendered as Jeff and Adam suggest), and that only the
    application should be allowed to switch to a new response tree.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>InitialRequestURLs-35</id>
  <originator>Hans</originator>
  <summary>URL contents for first view request, UIForm, UICommand</summary>
  <description>
    <p>We have discussed on different threads how to encode the
    tree id and other information in URLs.  This needs to be defined in
    the spec.  The most recent suggestion (my proposal modified with
    Craig's response) is:</p>
    <ul>
    <li>First request:  /{context.path}/{tree.id}</li>
    <li>UIForm:  /{context.path}/{tree.id} (form name can be deduced
        from the submit button that was used (<em>CRM</em>:  but only if
        we can use <code>UIComponent.getParent()</code> -- see
        [ComponentTreeParent-36])</li>
    <li>UICommand:  /{context.path}/faces/command/{command.name}/{tree.id}.
        </li>
    </ul>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>ComponentTreeParent-36</id>
  <originator>Adam</originator>
  <summary>Should component trees have parent links?</summary>
  <description>
    <p>The current implementation of UIComponent maintains links from a
    component to its parent, which implies that you can't recycle parts of
    a tree in more than one place, and other interesting things like that.
    This feature is quite important in most use cases of collaboration between
    components in a hierarchy (analogous to the issues of JSP custom tags
    collaborating with each other).</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>RequiredValidator-37</id>
  <originator>Hans</originator>
  <summary>Semantics of RequiredValidator needs refinement</summary>
  <description>
    <p>The RequiredValidator accepts an empty string as valid,
    but this means the validator is useless for a required text field,
    since HTML always generates an empty request parameter for an empty
    text field.  Combining it with LengthValidator, as was being suggested
    when I raised the issue, doesn't help; sure, the LengthValidator will
    catch it but the RequiredValidator is still useless and never generates
    an appropriate error message for an empty field.</p>

    <p>Adam added that we also have a reverse problem; an optional text
    field that must accept an empty string, but if it has a value, it
    must be possible to let a validator validate the value.  This is not
    possible today, but he suggested that a solution to both problems is
    to add a "required" property on UIInput (and others, I'm sure) instead
    and only validate when the component has a value.  This would replace
    the RequiredValidator.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>StandardComponentEvents-38</id>
  <originator>Hans</originator>
  <summary>Should standard UI components generate events?</summary>
  <description>
    <p>It's been suggested that some of them should at least generate
    "value changed" when a new value is detected in decode() or setValue().
    I've also suggested that "invalid value" events are posted during
    validation, to make it possible to handle this case in an event
    handler (implying that error messages are displayed, and making it
    more flexible at the same time.</p>

    <p>See Also:  [Listeners-3], [EventProcessingPhases-39].</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>EventProcessingPhases-39</id>
  <originator>Hans</originator>
  <summary>Do we need more than one event processing phase?</summary>
  <description>
    <p>If we implement [StandardComponentEvents-38], the answer is
    yes.  We probably need to process events in the Handle Events phase
    until the queue is empty (as opposed to the one pass approach), since
    new events may be triggered in this phase.  We may also need new event
    processing phases after other phases, such as Validation, Update Model
    Values, and Invoke Application.</p>

    <p>Jeff:  Two particular phases that might be useful:</p>
    <ul>
    <li>OnLoad -- Walks the component tree after Reconsitute Request Tree
        but before Apply Request Values.</li>
    <li>OnUnload -- Walks the component tree after Render Response
        for cleanup purposes.</li>
    </ul>

    <p>See Also:  [Listeners-3], [StandardComponentEvents-38].</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>UntypedStrings-40</id>
  <originator>Hans</originator>
  <summary>Should we replace untyped Strings with typesafe enums?</summary>
  <description>
    <p>I made a proposal (with an example) for the component type
    attribute used by the renderers, but the same applies to all cases
    where we use Strings that need to be unique.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>DecodeEncode-41</id>
  <originator>EG</originator>
  <summary>Names for decode and encode methods</summary>
  <description>
    <p>Many of us are uncomfortable with the names of the decode and
    encode methods.  Craig feels that the names should be "paired" in
    some fashion because the logic they implement must be complementary.
    Consider:  decode/renderXxx.  parse/renderXxx.  applyRequest/renderXxx.</p>

    <p>Adam:  Additional naming to think about:</p>
    <ul>
    <li>"Handle Request Events" to "Process Request Events".</li>
    <li>UIComponent.processEvents() to processRequestEvents().</li>
    <li>UIComponent.processValidators() to processValidation().</li>
    </ul>
  </description>
  <resolution>
    <p><em>02 Oct 2002</em> - Transfer to [UsabilityRenames-59].</p>
  </resolution>
  <status>CLOSED</status>
  <status-date>02 Oct 2002</status-date>
  <priority>5</priority>
  <effort></effort>
</issue>


<issue>
  <id>ValidatorsAPI-42</id>
  <originator>Adam</originator>
  <summary>Add value parameter to Validator.validate()?</summary>
  <description>
    <p>Currently, validators receive a FacesContext and UIComponent.
    They are expected to turn around and immediately call
    <code>UIComponent.getValue()</code>.  However, this means:</p>
    <ul>
    <li>No Validator can ever be used to validate anything other than
        the primary value of its component.  A component that needs two
        values will be forced to roll its own new Validators.</li>
    <li>A component that wishes to validate the client side representation
        (the String value) differently from the type-converted value cannot.
        </li>
    <li>getValue() is called once for each Validator.  Shouldn't be
        expensive performance-wise, but ...</li>
    </ul>
    <p>This can all be fixed by simply adding the Object value to
    Validator.validate().  We can (and should) still send the UIComponent
    instance.</p>

   <p>How do we handle "form level" validation, rather than "component
   level" validation?</p>
    
  </description>
  <resolution>
   <p>5 November 2002 - edburns - Added content from http://forum.java.sun.com/thread.jsp?forum=427&amp;thread=319464 </p>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>TraversalOrder-43</id>
  <originator>Adam</originator>
  <summary>Specify component tree traversal order</summary>
  <description>
    <p>For each phase, we need to answer the following questions:</p>
    <ul>
    <li>What order should components be traversed?</li>
    <li>In particular, are parents traversed before or after their
        children?</li>
    <li>Would a parent need to execute code both before <strong>and</strong>
        after its children?</li>
    <li>Do parents ever need to control the traversal of their children
        (e.g. skip child traversal, run traversal multiple times?)</li>
    </ul>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>12 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>ValidatorParams-44</id>
  <originator>Hans</originator>
  <summary>Should we set validation properties on the validator instance
           instead of on the component</summary>
  <description>
    <p>I suggested a while ago that the validation arguments should be
    properties of the validator instead of being handled as untyped
    attributes on the component, and got a lot of support from Adam,
    Jeff, and Craig.  It greatly simplifies both the JSP and the
    non-JSP cases.</p>

  </description>
  <resolution>
    <p><em>12 Sep 2002</em> - Partially implemented in 0902 draft, but
    spec needs updating (esp. 3.5.2.x and 3.1.7 example).</p>
    <p><em>02 Oct 2002</em> - Spec updates were completed for 0920 draft.</p>
  </resolution>
  <status>CLOSED</status>
  <status-date>02 Oct 2002</status-date>
  <priority>5</priority>
  <effort></effort>
</issue>


<issue>
  <id>MultiRequest-45</id>
  <originator>Bart &amp; Kris</originator>
  <summary>What about rendering that takes more than one HTTP request?</summary>
  <description>
    <p>One cannot assume that rendering <em>one</em> complete response
    view is completed in <em>one</em> HTTP request/response cycle.
    RenderKits may contain render strategies that take more than one cycle
    to complete the response view rendering.</p>

    <p>For more background, and sample scenarios, see the EG mailing list
    message from Kris on 09/13/2002 entitled "Request Processing Lifecycle
    Issue."</p>

    <p>Craig:  Might become a JSF 1.1 issue.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>NonVisual-46</id>
  <originator>Bart &amp; Kris</originator>
  <summary>Component names that assume visual rendering</summary>
  <description>
    <p>We have always found the decision to look for inspiration in the
    XForms standard to name the JSF components charming.  The reason is
    that it has brought JSF a <em>not to be underestimated</em>
    differentiator to ASP.NET Web Forms, at least theoretically.  Our
    components are completely render-independent; not even the
    visual/non-visual choice is made, as in XForms.</p>

    <p>That's the reason why we are not favoring the addition of the
    'visual' (<em>SPEC LEAD NOTE - is this a reference to the 'visible'
    versus 'shouldRender' discussion?) attribute on UIComponent.  An
    'encoded' attribute, however, would make sense.</em>)</p>

    <p>The render-independent component model should theoretically also
    cater for building voice user interfaces with JSF.  Two times already
    we have written 'theoretically' because of course it requires a POC
    before one can really make the statement.</p>

    <p>Unfortunately, two components in the current spec seem not to fit
    the above description:  UIGraphic and UIPanel.  The naming clearly
    suggests that these components are visual.  At least, we cannot
    envisage anything that would represent such things in for example
    a voice user interface.  It could be that these components are simply
    not part of such a user interface and that the remainder of the
    components forms the full set for non-visual interfaces.  However,
    we don't think so.</p>

    <p>For more background, and sample scenarios, see the EG mailing list
    message from Kris on 09/13/2002 entitled "Render-Independent UI
    Component Model Catering for Visual and Non-Visual Interfaces."</p>
  </description>
  <resolution>
    <p><em>21 Oct 2002</em> - Merge into [UsabilityRenames-59].</p>
  </resolution>
  <status>CLOSED</status>
  <status-date>21 Oct 2002</status-date>
  <priority>2</priority>
  <effort>Medium</effort>
</issue>


<issue>
  <id>ValidatorCombos-47</id>
  <originator>Hans</originator>
  <summary>Is an AND-based validation model sufficient?</summary>
  <description>
    <p>Is the AND-based validation model sufficient, or do we need to
    support a more sophisticated model where both AND and OR relations
    between validators can be defined?</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>GenericAttributes-48</id>
  <originator>Hans</originator>
  <summary>Can we eliminate use of generic component attributes?</summary>
  <description>
    <p>Currently, a component is associated with a RendererType and the
    JSF implementation finds an instance of this type when needed.  The
    renderer may then use generic attributes of the component to adjust
    its behavior.  If we implement <code>[ValidatorParams-44]</code>, this
    is the last specific use of Generic Attributes defined by the spec (the
    spec says they can also be used for application-specific, general
    purpose attributes).</p>

    <p>Would we lose anything by handling renderers the same as we
    handle Validators (as per [ValidatorParams-44]), i.e. associate a
    specific Renderer <em>instance</em> with the component instead of
    a type?  It would make the model more consistent, and probably provide
    the same simplifications as [ValidatorParams-44]).  I assume that an
    argument against it is that it makes it impossible (or at least harder)
    to switch from one RenderKit to another for an existing tree, but how
    useful is that really?</p>

    <p>(<em>Spec Lead Note - one implication to consider is that Renderer
    instances would need to be Serializable, or some other mechanism for
    saving and restoring them would need to be provided.</em>)</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>AbstractClassNames-49</id>
  <originator>Hans</originator>
  <summary>Naming convention for abstract base classes</summary>
  <description>
    <p>Currently, our abstract base classes have the naming convention
    <code>FooBase</code> (such as UIComponentBase, etc.).  Some other Java
    APIs use the convention <code>AbstractFoo</code> for this concept
    instead.  Should we switch?</p>
  </description>
  <resolution>
    <p><em>21 Oct 2002</em> - Merged into [UsabilityRenames-59].</p>
  </resolution>
  <status>CLOSED</status>
  <status-date>21 Oct 2002</status-date>
  <priority>2</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>NonPublicClasses-50</id>
  <originator>CTS</originator>
  <summary>Non-Public Classes in jsf-api</summary>
  <description>
    <p>The current <code>jsf-api</code> includes a couple of non-public
    base classes (like <code>ValidatorBase</code>) to assist in the
    implementation of some concrete classes that are part of the API.
    The design intent was that this was just an implementation choice
    made for this particular version of the API classes.
    The existence of such classes causes problems in the developing
    signature tests that validate the spec compliance of a particular
    version of the API classes.  We need to make such classes public,
    eliminate them, or perhaps remove the concrete classes from the
    API somehow.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Medium</effort>
</issue>


<issue>
  <id>MessageResources-51</id>
  <originator>Hans</originator>
  <summary>Can we remove MessageResources/MessageResourcesFactory</summary>
  <description>
    <p>Do we really need MessageResources/MessageResourcesFactory?  Does
    it offer significant features over what the regular ResourceBundle
    class offers (I can't see any)_?  For the FACES_API_MESSAGES and
    FACES_IMPL_MESSAGES resources, we could instead require JSF implementations
    to make ResourceBundles with javax.faces.* names available.</p>

    <p><em>(Craig - eliminating these would also assist in interoperating
    with JSTL's i18n classes, which already use resource bundles)</em></p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>Lifecycle-52</id>
  <originator>Hans</originator>
  <summary>Do we need to support additional phases, or have Lifecycle at all?</summary>
  <description>
    <p>Do we really have strong use-cases for supporting additional phases?
    It seems to complicate things and a feature that may impact the
    portability of components.</p>

    <p>Additional note from Joe:  Should we allow Phase.execute() to return
    any phase identifier value, instead of just symbolic constants for the
    known cases?</p>

    <p><em>(Craig - additionally, if we relax the rules to allow a JSF
    implementation to simply call the standard Phase implementations in the
    right order, and obey the return value appropriately, we might not
    need Lifecycle/LifecycleFactory at all.)</em></p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>BackButton-53</id>
  <originator>Joe</originator>
  <summary>Dealing with the browser BACK button</summary>
  <description>
    <p>What should the spec say about the eternal issues of dealing with
    a browser user using the BACK button, such as transaction tokens to
    avoid processing the same form submit more than once?  Note that tokens
    should be scoped to specific forms, not a global property of a JSF
    implementation (i.e. probably don't want one on search forms).</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>DefaultRendering-54</id>
  <originator>Joe</originator>
  <summary>Should components have default decode/encode behavior?</summary>
  <description>
    <p>We currently describe default behavior for the <code>decode()</code>
    and <code>encodeXxx()</code> methods of standard component classes.  This
    was done originally to avoid the case where a page author forgets to
    set the renderer type, and no decode/encode processing at all is performed.
    (Note that this won't happen in the typical JSP case, because setting the
    renderer type is implicit in the choice of tag used).  Do we still want
    this?</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>2</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>TypeSpecificRenderers-55</id>
  <originator>Joe</originator>
  <summary>Should converters replace type-specific renderers like
           Date, DateTime, and Time?</summary>
  <description>
    <p>The recently added Converter functionality has a lot of overlap with
    the previously defined Date, DateTime, and Time renderers.  Do we want
    to keep both?  Don't forget to consider the usability implications on
    how you specify such things in a JSP page (in particular, how you
    parametrically configure converters for things like date patterns).</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>18 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>URLs-56</id>
  <originator>Adam</originator>
  <summary>Should JSF perform context-path prefixing on "/" URLs?</summary>
  <description>
    <p>The current description of UIGraphic states that JSF will add a
    context path prefix in front of URLs that begin with a "/" character.
    This feature is replicated in other places where URLs are specified.</p>

    <p>Struts developers have found the automatic prefixing functionality
    to be very useful, but Adam is concerned because it changes semantics
    that webapp developers might be expecting (i.e. '/' URLs are server
    relative).  Do we want to keep this behavior?</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>RendererDelegation-57</id>
  <originator>Adam</originator>
  <summary>Should UIComponent delegate more methods to Renderer?</summary>
  <description>
    <p>Currently, UIComponent delegates decode(), encodeBegin(),
    encodeChildren(), and encodeEnd() methods to a Renderer if the
    rendererType property is set.  It may make sense to delegate some
    additional methods as well, including</p>
    <ul>
    <li>getRendersChildren() - if a Renderer wants to override the value
        normally returned by a component for this property.</li>
    <li>updateModel() - if a Renderer wants to add a "readonly" attribute
        to a UIInput component.</li>
    </ul>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Medium</effort>
</issue>


<issue>
  <id>FacesContext-58</id>
  <originator>Adam</originator>
  <summary>Should FacesContext be factored out into APIs for related
           sets of methods?</summary>
  <description>
    <p>Recently, we have been moving towards a lot of functionality
    added to FacesContext, to the degree where it might be too confusing.
    Example:  MessageList used to be a separate object that had all the
    message queue related methods.  Do we want to continue this trend,
    or reverse it?</p>

    <p>For the FacesContext user, it makes calling simpler
    (<code>context.addMessage()</code> instead of
    <code>context.getMessageList().addMessage()</code>), at the cost
    of lots of methods on FacesContext.</p>

    <p>In addition, it may be appropriate to consider factoring <em>in</em>
    method calls to eliminate the need for components and applications to
    use factories to retrieve MessageResources and Converter instances.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>UsabilityRenames-59</id>
  <originator>EG</originator>
  <summary>Should classes and methods be renamed for usability?</summary>
  <description>
    <p>A variety of class and method renames have been suggested to improve
    usability.  This issue is an omnibus to address them.  Included:</p>
    <ul>
    <li><strong>UIComponent</strong> - Change "modelReference" to "ref"
        for XForms consistency (Craig - I think going back to "model" would
        be better than this unless the semantics match exactly).</li>
    <li><strong>UIGraphic</strong> - Change to "UIMedia" or "UIResource"
        to remove visual connotation.</li>
    <li><strong>UIPanel</strong> - Change to something that doesn't connote
        visual representation (UIContainer?  UIManager?).</li>
    <li><strong>UISelectMany</strong> - Rename to UISelect (new XForms).</li>
    <li><strong>UISelectOne</strong> - Rename to UISelect1 (new XForms).</li>
	  <li><strong>decode/encode</strong> - change to parse/render</li>

    </ul>
    <p>It's also worth reviewing the recent XForms 1.0 working draft
    (08/21/2002) because they've changed some of the component names we
    originally copied.</p>

<p>Also check out Adam's post <a href="http://swjscmail1.java.sun.com/cgi-bin/wa?A2=ind0209&amp;L=jsr-127-eg&amp;D=0&amp;X=6F83683A67B23EB98E&amp;Y=ed.burns@sun.com&amp;P=14616">on the VisibleProperty thread</a>.</p>

  </description>
  <resolution>
    <p><em>02 Oct 2002</em> - Consolidate [DecodeEncode-41] into this.</p>
    <p><em>21 Oct 2002</em> - Merge in [NonVisual-46] and
       [AbstractClassNames-49].</p>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Medium</effort>
</issue>


<issue>
  <id>ValidatorMessages-60</id>
  <originator>Jeff</originator>
  <summary>We should allow "validation message" attributes to be specified
           along with the other configuration properties</summary>
  <description>
    <p>See Jeff's "comments on the 0902 spec" message dated 09/13/2002.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>URLRewriting-61</id>
  <originator>Jeff</originator>
  <summary>Should URL rewriting be performed on generated URLs?</summary>
  <description>
    <p>Currently, the spec required URL rewriting on generated URLs.  Should
    this be unconditional, conditional, or not performed?</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>FileUpload-62</id>
  <originator>Jeff</originator>
  <summary>Do we need a file upload component/renderer?</summary>
  <description>
    <p>It would be useful to have a component and/or renderer for processing
    file uploads.</p>

    <p>Sounds like a good JSF 1.1 feature addition.</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>4</priority>
  <effort></effort>
</issue>


<issue>
  <id>XForms-63</id>
  <originator>Jeff</originator>
  <summary>Additional XForms input types to be supported?</summary>
  <description>
    <p>Should we support additional XForms input types:  range, trigger,
    submit?</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>RenderKitComponents-64</id>
  <originator>Jeff</originator>
  <summary>The relationship between renderkits and component types/classes
           seems confusing and duplicative</summary>
  <description>
    <p>Currently, we register components with renderkits by either component
    type or class.  Do we need both, or only one?  If one, which?</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>1</priority>
  <effort>Medium</effort>
</issue>


<issue>
  <id>BrowserVersions-65</id>
  <originator>Jeff</originator>
  <summary>Reconfirm browser versions supported by standard RenderKit</summary>
  <description>
    <p>What browsers are we going to certify the standard RenderKit against?
    (Currently we just say "HTML/4.01").  Despite what we claim for this,
    what concessions are we willing to make for back-level browsers?</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>XHTML-66</id>
  <originator>Jeff</originator>
  <summary>Mandatory or optional XHTML/1.0 compatibility?</summary>
  <description>
    <p>How much (if any) should we specify for the standard HTML render kit
    (beyond HTML/4.01) for compatibility with XHTML/1.0?</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>20 Sep 2002</status-date>
  <priority>3</priority>
  <effort></effort>
</issue>


<issue>
  <id>JstlDependencies-67</id>
  <originator>Craig</originator>
  <summary>Should we mandate a JSTL 1.0 dependency when using JSP?</summary>
  <description>
    <p>For JSF page authors using JSP as their rendering technology, it is
    highly desireable that we interoperate seamlessly with JSTL tags and
    APIs where appropriate.  Examples include:</p>
    <ul>
    <li>A data grid ([DataGrid-16]) should be able to process data provided
        via a <code>javax.servlet.jstl.sql.Result</code>, among others.</li>
    <li>Localization should be sensitive to any current
        <code>javax.servlet.jsp.jstl.fmt.LocalizationContext</code>.</li>
    <li>Iterative rendering might need to interoperate with JSTL iteration
        constructs, including
        <code>javax.servlet.jsp.jstl.core.LoopTagStatus</code>.</li>
    </ul>

    <p>Note that the data structure APIs (like Result) may be useful for
    application developers even in a non-JSP rendering environment.  However,
    doing any of this means we must declare a dependency on having a JSTL 1.0
    implementation available, along with a JSF 1.0 implementation (and of
    course Servlet 2.3 and JSP 1.2).</p>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>03 Oct 2002</status-date>
  <priority>1</priority>
  <effort>Small</effort>
</issue>


<issue>
  <id>VerbatimOutput-68</id>
  <originator>EG</originator>
  <summary>Need a mechansim for including raw HTML (or whatever)</summary>
  <description>
    <p>Although JSF components will normally generate the HTML (or other)
    markup language to render themselves, there are cases where we'd like
    to be able to output raw markup directly.  In a JSP page, you can do
    that using embedded template text, but there needs to be a mechanism
    for this purpose at the component API level.  Options include:</p>
    <ul>
    <li>New <code>UIVerbatim</code> component that specifically contains
        markup, but is otherwise treated similarly to <code>UIOutput</code>.
        </li>
    <li>New <code>Verbatim</code> Renderer that treats any
        <code>UIOutput</code> component as the source of raw markup,
        and just renders it literally.  <em>(Craig:  I'm not sure that
        this is functionally any different than the <code>Text</code>
        renderer processing an UIOutput component, unless we decide to
        make that one do some sort of filtering for characters sensitive
        to HTML.)</em></li>
    </ul>
  </description>
  <resolution>
  </resolution>
  <status>OPEN</status>
  <status-date>08 Oct 2002</status-date>
  <priority>1</priority>
  <effort>Small</effort>
</issue>


</issues>
