<?xml version="1.0"?>

<!-- Informal DTD for contents of "issue" subelements:

  id                Unique issue identifier
  originator        EG member (or public comment) that originated the issue
  summary           Summary one-line description
  description       Full (multiline) description of the issue
  resolution        Full (multiline) description of resolution
  status            OPEN, CLOSED, LATER
  date              Date on which status was last changed

-->

<issues>


<issue>
  <id>ObjectManager-1</id>
  <originator>Craig</originator>
  <summary>Re-introduce Object Manager Functionality</summary>
  <description>
    <p>Currently, it is inconvenient to use request scope beans in
    model reference expressions, because the corresponding object
    is not created automatically.  This was one of the features provided
    in the <em>Object Manager</em> functionality that was present in
    version .03 of the JSF Spec, but has been absent since.</p>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Craig to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>OutputMethods-2</id>
  <originator>Craig</originator>
  <summary>Consider refactoring OutputMethod from ResponseWriter</summary>
  <description>
    <p>Currently, the extended methods for writing elements and attributes
    (proposed by Adam) are defined on <code>ResponseWriter</code> directly.
    The current implementation of <code>javax.faces.webapp.FacesTag</code>
    requires a concrete implementation of <code>JspResponseWriter()</code>
    to be in the API classes, which is undesireable for something as
    detailed as these methods.  Options to consider:</p>
    <ul>
    <li>Modify <code>FacesTag</code> so that it can look up an
        implementation of <code>JspResponseWriter</code> somehow.</li>
    <li>Extract the element and attribute methods into a wrapper API
        around a ResponseWriter (analogous to the way that
        <code>java.io.FilterWriter</code> can wrap a Writer.  (Still
        need a generic discovery mechanism though).</li>
    </ul>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Craig to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>Listeners-3</id>
  <originator>Craig</originator>
  <summary>Review Event Listener Architecture</summary>
  <description>
    <p>Need to review how the event listener mechanism is currently
    architected in light of real world component development.  In
    particular:</p>
    <ul>
    <li>Registering listeners on a receiving component (versus globally).</li>
    <li>Directing events to a particular component (versus a global
        "this thing happened" approach).</li>
    </ul>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Craig to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>NamedChild-4</id>
  <originator>Adam</originator>
  <summary>Reintroduce "Named Child" Concept for UIComponents</summary>
  <description>
    <p>Introduce a concept similar to what JSP 2.0 has introduced with
    <code>&lt;jsp:attribute&gt;</code> and the JspFragment class, in
    order to facilitate building complex UI components.</p>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Adam to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>StateSaving-5</id>
  <originator>Adam</originator>
  <summary>Re-evaluate Question of State Saving Volume/Location</summary>
  <description>
    <p>We currently put the onus for this on the JSP <code>use_faces</code>
    tag, which is not sufficiently generalized to support non-JSP uses.</p>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Adam to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>ServletDependencies-6</id>
  <originator>Adam</originator>
  <summary>Servlet API Dependencies</summary>
  <description>
    <p>To what extent do we wish to abstract away the current dependencies
    on the servlet API?  This may be necessary for the Portlet JSR, and
    it would be necessary for using JSF to create content outside of
    servlets.</p>
  </description>
  <resolution>
    <p><em>04 Sep 2002</em> - Adam to present writeup to EG.</p>
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>JspDependencies-7</id>
  <originator>Hans</originator>
  <summary>JSP API Dependencies</summary>
  <description>
    <p>Although there are many who suggest we base JSF on JSP 1.2 for
    immediate acceptance reasons, it forces us to do any custm tag
    implementation classes based on the JSP 1.2 Tag and BodyTag APIs.
    Can we avoid creating a dependency like this that ties us to this
    API (which could potentially be deprecated in some future JSP spec)?</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>ELDependencies-8</id>
  <originator>Hans</originator>
  <summary>JSP EL API Dependencies</summary>
  <description>
    <p>Basing JSF on JSP 1.2 means we must specify our version of the EL
    language being used for model references in the JSF specification (or
    perhaps point at the non-normative one in JSTL 1.0), since we would
    not want to tie ourselves to the JSP 2.0 formal definition of the
    language.  Is this acceptable?  Can we deal with it in a different
    way?</p>

    <p>In addition, we currently need a feature that is not supported by
    the JSTL 1.0 or JSP 2.0 versions of the EL -- model object
    <em>setting</em> as well as getting.  We're going to need to address
    the syntax and semantics of this no matter what JSP version we choose
    to depend on.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>TreeCreation-9</id>
  <originator>Jeff</originator>
  <summary>Component Tree Creation in Render Response</summary>
  <description>
    <p>Our current design uses a pass through <em>Render Response</em> to
    initially create the component tree in most cases, which makes for
    interesting design decisions on some complex rendering scenarios.  It
    would be useful to re-investigate creating the component tree from a
    static analysis of the JSP page source.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>ComponentNamespace-10</id>
  <originator>Jeff</originator>
  <summary>Component Identifier Namespace</summary>
  <description>
    <p>We currently use a hierarchical namespace for components, both
    in the tree itself and in the rendered page.  Among other things,
    this causes a problem with rendering <code>id</code> attributes on
    the output HTML elements, because '/' is not a valid IDREF character.
    Should we go to a flat namespace for components (at least in the
    rendered output, and perhaps in addition to hierarchical names)?</p>

    <p>We will also need a way for components to predict what the rendered
    <code>id</code> attribute for a component was (if it has been rendered)
    or will be (if it has not been rendered yet) in order to generate
    corresponding JavaScript.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>ApplicationHandler-11</id>
  <originator>Public</originator>
  <summary>Rethink ApplicationHandler</summary>
  <description>
    <p>Please rethink this ApplicationHandler business.  Application
    handlers are going to wind up having a processEvent method that's
    a huge switch statement that switches off the event type and forces
    casting, thereby committing three Cardinal OO sins.  Another huge
    drawback to this design is that the application handler accesses
    tree ids directly, which will increase the maintenance burden if you
    happen to change the name of a JSP page that the application handler
    forwards to.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>ModelReferences-12</id>
  <originator>Public</originator>
  <summary>Are modelReference attributes required?</summary>
  <description>
    <p>Must I really specify a modelReference attribute for every component?
    That really increases the verbosity of my JSP pages -- for those like me
    that suffer from RSI its a real pain.  It certainly also painful for those
    that don't suffer from RSI.</p>

    <p>Can't the association be done with reflection?  Can't the form beans
    be specified in a configuration file?  Please?</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>XmlModel-13</id>
  <originator>Public</originator>
  <summary>Please include support for an XML Model</summary>
  <description>
    <p>Great work on this JSR.  I think it will debunk the claim that
    Visual Studio .NET is "easier to use" than J2EE development products.</p>

    <p>What you are missing here is support for an XML model rather than
    JavaBeans.  JSTL has excellent support for rendering an XML model and
    I am surprised to find this lacking in JSR-127.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>CommandHyperlink-14</id>
  <originator>RI Team</originator>
  <summary>Cannot implement command_hyperlink as specified</summary>
  <description>
    <p>The decode behavior of the <code>Hyperlink</code> Renderer is
    currently specified as "send a CommandEvent to the application."
    However, the current definition of phase switching does not provide
    a path from <em>Process Request Events</em> to <em>Invoke
    Application</em> without going through validations and model updates.
    These phases are inappropriate in a CommandEvent scenario, because
    a form (and the corresponding input fields) did not get submitted.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>UserAgent-15</id>
  <originator>Craig</originator>
  <summary>Do we need a UserAgent classification scheme?</summary>
  <description>
    <p>So far during the development of the Standard HTML RenderKit,
    it has not been necessary to emit any browser-specific code.  Such
    a need might come in the future, and will certainly be necessary
    for user-created components that create complex DHTML and/or JavaScript
    code that depends on the DOM of the browser being targeted.</p>

    <p>Making applications parse the <code>User-Agent</code> header seems
    like something we might want to abstract away.  Because not all
    RenderKits will target web browsers, it's not just a matter of
    identifying what browser type is in use.  Perhaps a UserAgentClassifier
    plug-in interface that is part of the RenderKit?</p>

    <p>If we ever do start emitting browser-dependent code from the
    standard RenderKit, it's also important to understand how caches
    can negatively affect application behavior by caching the content
    for one browser and serving it to another.  This only happens if the
    request URL is identical, which is something to avoid.</p>

    <p>NOTE:  JSR188 <a href="http://jcp.org/jsr/detail/188.jsp">
    http://jcp.org/jsr/detail/188.jsp</a> is operating in this space.
    We should take its development into account.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>04 Sep 2002</status-date>
</issue>


<issue>
  <id>DataGrid-16</id>
  <originator>Jeff</originator>
  <summary>What should a DataGrid control look like?</summary>
  <description>
    <p>Many existing GUI frameworks for web applications have data grid
    controls that allow page authors to do relatively sophisticated hookups
    to back end data sources.  It is very likely that Faces will need
    such a control as well.  What should it look like, in terms of the
    Faces component and renderer design?</p>

    <p>Besides supporting JavaBean arrays, Collections, and Maps (like the
    propotype "List" renderer in jsf-psuedo) does, we should consider
    supporting a control whose model reference points at either a JSTL
    <code>java.servlet.jsp.jstl.sql.Result</code> or a JDBC
    <code>java.sql.ResultSet</code> (or <code>RowSet</code>) directly.
    Using a <code>Result</code> object would allow very easy interoperability
    with JSTL's SQL tags.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>05 Sep 2002</status-date>
</issue>


<issue>
  <id>NonJSPRendering-17</id>
  <originator>Hans</originator>
  <summary>Non-JSP Rendering Environment</summary>
  <description>
    <p>We have spent a significant amount of effort on making sure that Faces
    interacts well with JSP and related technologies (such as JSTL).  We need
    to prove (at a minimum to ourselves) that the basic APIs support rendering
    in a non-JSP environment as well.  How much of this should show up in
    the RI?  Or in ancillary distributions (along with enhanced renderkits)?
    </p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>05 Sep 2002</status-date>
</issue>


<issue>
  <id>TreeClass-18</id>
  <originator>EG</originator>
  <summary>Tree/TreeFactory Classes Needed?</summary>
  <description>
    <p>One of the original motivations for the <code>Tree</code> and
    <code>TreeFactory</code> classes was the notion of constructing an
    entire component tree from some external metadata.  Our current approach
    that allows the tree to be constructed dynamically during Render Response
    makes the need for this substantially weaker.</p>

    <p>Can we get rid of TreeFactory entirely?  Probably.</p>

    <p>Can we get rid of Tree as well?  Possibly -- at the cost of replacing
    two FacesContext properties (<code>requestTree</code> and
    <code>responseTree</code>) with six (<code>renderKitId</code>,
    <code>root</code>, and <code>treeId</code> for each of the two trees).</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>05 Sep 2002</status-date>
</issue>

<issue>
  <id>EventTypes-19</id>
  <originator>EG</originator>
  <summary>Both FormEvent and CommandEvent?</summary>
  <description>
    <p>The current APIs have both CommandEvent (passes the command name)
    and FormEvent (subclasses CommandEvent and adds the form name).  Do we
    need both?  It would seem that command event is required in any case
    (so that an application can distinguish which submit button was used).
    Does FormEvent add enough value to make it worth keeping?</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
</issue>


<issue>
  <id>UIParameter-20</id>
  <originator>EG</originator>
  <summary>Should UIParameter be a component?</summary>
  <description>
    <p>Should UIParameter be a component?  If it's not, how would we do
    things like specify the substitution parameters for the
    <code>Message</code> renderer type?</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
</issue>


<issue>
  <id>UIComponentBase-21</id>
  <originator>EG</originator>
  <summary>UIComponentBase exists in API but not Spec</summary>
  <description>
    <p>Based on EG feedback, UIComponent was converted from an abstract class
    to an interface, and UIComponentBase added as an abstract class.  This
    change has not yet been reflected in the spec.  Do we want to keep it?
    If so, the spec needs to be updated to reflect this.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
</issue>


<issue>
  <id>OASIS-22</id>
  <originator>Kris &amp; Bart</originator>
  <summary>Relationship with WSIA/WSRP Work</summary>
  <description>
    <p>Review current progress on the OASIS <em>Web Services for Interactive
    Applications</em> and <em>Web Services for Remote Portals</em>, and
    make any needed recommendations for changes in JSF.</p>

    <p><a href="http://www.oasis-open.org/">http://www.oasis-open.org</a></p>

    <p>NOTE:  WSRP seems to me (Craig) to be clearly in the JSR168 sphere.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
</issue>


<issue>
  <id>PortletTerminology-23</id>
  <originator>Kris &amp; Bart</originator>
  <summary>Alignment with JSR168 Terminology Definitions</summary>
  <description>
    <p>We should ensure that there is alignment between terminology definitions
    in JSR168 (Portlets) and JSR127 (Faces) where the concepts are the same.
    </p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
</issue>


<issue>
  <id>FacesServlet-24</id>
  <originator>Kris &amp; Bart</originator>
  <summary>Should we use FacesServlet or FacesFilter</summary>
  <description>
    <p>Re-examine our current choice of using a Servlet instead of a Filter
    for the Faces mini-front-controller.  Among the issues:</p>
    <ul>
    <li>JSR168 choice to mimic servlet APIs instead of extend them.</li>
    <li>Filters don't work on RequestDispatcher.include() calls on Servlet
        2.3 (but this is possible in Servlet 2.4).</li>
    </ul>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
</issue>


<issue>
  <id>LookAndFeel-25</id>
  <originator>Kris &amp; Bart</originator>
  <summary>How will JSF address look and feel</summary>
  <description>
    <p>This is a somewhat open ended question.  The philosophy in the 0902
    version of the standard renderers is to delegate as much of possible to
    CSS stylesheets and give page authors the ability to configure the
    stylesheet class (or classes) to use for rendering each component.
    That seems to be the direction that W3C encourages for HTML.  Is that
    the way we want to stay?</p>

    <p>NOTE:  Running the jsf-pseudo examples under Netscape 4.x looked
    surprisingly better than I thought it would, but there are going to be
    obvious issues around stylesheet directives that 4.x doesn't support
    or implements incorrectly.</p>
  </description>
  <resolution>
    
  </resolution>
  <status>OPEN</status>
  <status-date>06 Sep 2002</status-date>
</issue>


</issues>
